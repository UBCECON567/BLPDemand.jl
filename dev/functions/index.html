<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Function Reference · BLPDemand.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">BLPDemand.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../simulation/">Simulations</a></li><li class="is-active"><a class="tocitem" href>Function Reference</a><ul class="internal"><li><a class="tocitem" href="#Index-1"><span>Index</span></a></li></ul></li><li><a class="tocitem" href="../implementation/">Developer Notes</a></li><li><a class="tocitem" href="../replicateblp/">Replicating BLP</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Function Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Function Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/UBCECON567/BLPDemand.jl/blob/master/docs/src/functions.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Function-Reference-1"><a class="docs-heading-anchor" href="#Function-Reference-1">Function Reference</a><a class="docs-heading-anchor-permalink" href="#Function-Reference-1" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="BLPDemand.BLPData" href="#BLPDemand.BLPData"><code>BLPDemand.BLPData</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Data set for BLP demand model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/UBCECON567/BLPDemand.jl/blob/f8de800c2fbe03a1e330962ecaefaa924f4f887b/src/data.jl#LL35-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BLPDemand.BLPData-Tuple{AbstractArray{T,2} where T,AbstractArray{T,3} where T,AbstractArray{T,3} where T,AbstractArray{T,3} where T,AbstractArray{T,3} where T,AbstractArray{T,3} where T}" href="#BLPDemand.BLPData-Tuple{AbstractArray{T,2} where T,AbstractArray{T,3} where T,AbstractArray{T,3} where T,AbstractArray{T,3} where T,AbstractArray{T,3} where T,AbstractArray{T,3} where T}"><code>BLPDemand.BLPData</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Constructs data for BLP demand model from arrays. Compared to <a href="#BLPDemand.MarketData"><code>MarketData</code></a>, each argument should have one more dimension with length <code>T</code>=number of markets</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/UBCECON567/BLPDemand.jl/blob/f8de800c2fbe03a1e330962ecaefaa924f4f887b/src/data.jl#LL40-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BLPDemand.BLPData-Tuple{AbstractArray{T,2} where T,AbstractArray{T,3} where T,AbstractArray{T,3} where T,AbstractArray{T,3} where T}" href="#BLPDemand.BLPData-Tuple{AbstractArray{T,2} where T,AbstractArray{T,3} where T,AbstractArray{T,3} where T,AbstractArray{T,3} where T}"><code>BLPDemand.BLPData</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Constructs data for IV random coefficients logit model from arrays. Compared to <a href="#BLPDemand.MarketData"><code>MarketData</code></a>, each argument should have one more dimension with length <code>T</code>=number of markets</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/UBCECON567/BLPDemand.jl/blob/f8de800c2fbe03a1e330962ecaefaa924f4f887b/src/data.jl#LL58-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BLPDemand.BLPData-Tuple{DataFrames.DataFrame,Symbol,Symbol,Symbol,Array{Symbol,1},Array{Symbol,1},Array{Symbol,1},Array{Symbol,1},AbstractArray{T,3} where T}" href="#BLPDemand.BLPData-Tuple{DataFrames.DataFrame,Symbol,Symbol,Symbol,Array{Symbol,1},Array{Symbol,1},Array{Symbol,1},Array{Symbol,1},AbstractArray{T,3} where T}"><code>BLPDemand.BLPData</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function BLPData(df::AbstractDataFrame,
             mid::Symbol,
             firmid::Symbol,
             s::Symbol,                 
             x::Vector{Symbol},
             w::Vector{Symbol},
             zd::Vector{Symbol},
             zs::Vector{Symbol},
             ν::AbstractArray{T,3} where T)</code></pre><p>Construct BLPData from a DataFrame.</p><p><strong>Arguments</strong></p><ul><li><code>df::AbstractDataFrame</code></li><li><code>mid::Symbol</code> market identifier in <code>df</code></li><li><code>s::Symbol</code> market shares </li><li><code>x::Vector{Symbol}</code> columns of <code>df</code> of product characteristics. <code>x[1]</code> must be price</li><li><code>w::Vector{Symbol}</code> cost shifters</li><li><code>zd::Vector{Symbol}</code> demand instruments</li><li><code>zs::Vector{Symbol}</code> supply instruments</li><li><code>ν::Array{T, 3} where T</code> <code>K × S × T</code> array of draws for Monte Carlo integration</li></ul><p>See also <a href="#BLPDemand.MarketData"><code>MarketData</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/UBCECON567/BLPDemand.jl/blob/f8de800c2fbe03a1e330962ecaefaa924f4f887b/src/data.jl#LL75-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BLPDemand.MarketData" href="#BLPDemand.MarketData"><code>BLPDemand.MarketData</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Data from a single market for a BLP demand model</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/UBCECON567/BLPDemand.jl/blob/f8de800c2fbe03a1e330962ecaefaa924f4f887b/src/data.jl#LL1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BLPDemand.data_blp1999-Tuple{}" href="#BLPDemand.data_blp1999-Tuple{}"><code>BLPDemand.data_blp1999</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function loadblpdata()</code></pre><p>Loads data from Berry, Levinsohn, and Pakes (1999).</p><p>Returns a DataFrame.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/UBCECON567/BLPDemand.jl/blob/f8de800c2fbe03a1e330962ecaefaa924f4f887b/src/data.jl#LL124-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BLPDemand.delta-Union{Tuple{T}, Tuple{AbstractArray{T,1},AbstractArray{T,2},AbstractArray{T,2},AbstractArray{T,1}}} where T" href="#BLPDemand.delta-Union{Tuple{T}, Tuple{AbstractArray{T,1},AbstractArray{T,2},AbstractArray{T,2},AbstractArray{T,1}}} where T"><code>BLPDemand.delta</code></a> — <span class="docstring-category">Method</span></header><section><div><p>function delta(s, x, ν, σ;                 tol=sqrt(eps(eltype(s))), maxiter=1000)</p><p>Solves for δ in s = share(δ, ...) using contraction mapping iteration.</p><p>See also: <a href="#BLPDemand.share-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,2} where T,AbstractArray{T,2} where T}"><code>share</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/UBCECON567/BLPDemand.jl/blob/f8de800c2fbe03a1e330962ecaefaa924f4f887b/src/share.jl#LL165-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BLPDemand.demandmoments-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T,Array{MarketData,1}}" href="#BLPDemand.demandmoments-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T,Array{MarketData,1}}"><code>BLPDemand.demandmoments</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">demandmoments(β::AbstractVector,σ::AbstractVector,
                       dat::BLPData)</code></pre><p>Demand side moments in BLP model. </p><p><strong>Arguments</strong></p><ul><li><code>β</code> length <code>K</code> (=number characteristics) vector of average tastes for characteristics</li><li><code>σ</code> length <code>K</code> vector of standard deviations of tastes</li><li><code>dat::BLPData</code> </li></ul><p>Returns <code>(moments, ξ)</code> where vector of moments is length <code>L</code> with <code>moments[l] = 1/(JT) ∑ⱼ∑ₜ ξ[t][j]*dat[t].zd[l,j]</code></p><p>See also: <a href="#BLPDemand.share-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,2} where T,AbstractArray{T,2} where T}"><code>share</code></a>, <a href="#BLPDemand.delta-Union{Tuple{T}, Tuple{AbstractArray{T,1},AbstractArray{T,2},AbstractArray{T,2},AbstractArray{T,1}}} where T"><code>delta</code></a>, <a href="@ref"><code>simulateRCIVlogit</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/UBCECON567/BLPDemand.jl/blob/f8de800c2fbe03a1e330962ecaefaa924f4f887b/src/estimation.jl#LL1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BLPDemand.dsharedp-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,2} where T,AbstractArray{T,2} where T,AbstractArray{T,1} where T}" href="#BLPDemand.dsharedp-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,2} where T,AbstractArray{T,2} where T,AbstractArray{T,1} where T}"><code>BLPDemand.dsharedp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function dsharedp(β::AbstractVector,
              σ::AbstractVector,
              p::AbstractVector,
              x::AbstractMatrix,
              ν::AbstractMatrix,
              ξ::AbstractVector)</code></pre><p>Compute market shares and their derivatives in BLP random coefficients demand model.</p><p>See <a href="#BLPDemand.sharep-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,2} where T,AbstractArray{T,2} where T,AbstractArray{T,1} where T}"><code>sharep</code></a> for argument details.</p><p><strong>Returns</strong></p><ul><li><code>s</code> vector <code>J</code> market shares</li><li><code>ds</code> <code>J × J</code> Jacobian matrix with ds[l,j] = ∂s[l]/∂p[j]</li><li><code>Λ</code> <code>J × J</code> diagonal matrix with <code>ds = Λ - Γ</code></li><li><code>Γ</code> <code>J × J</code> matrix </li></ul><p>See <a href="#BLPDemand.eqprices-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,2} where T,AbstractArray{T,2} where T}"><code>eqprices</code></a> for usage of <code>Λ</code> and <code>Γ</code>.    </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/UBCECON567/BLPDemand.jl/blob/f8de800c2fbe03a1e330962ecaefaa924f4f887b/src/share.jl#LL109-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BLPDemand.eqprices-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,2} where T,AbstractArray{T,2} where T}" href="#BLPDemand.eqprices-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,2} where T,AbstractArray{T,2} where T}"><code>BLPDemand.eqprices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function eqprices(mc::AbstractVector,
                  β::AbstractVector, σ::AbstractVector,
                  ξ::AbstractVector,
                  x, ν;
                  firmid= 1:length(mc),
                  tol=sqrt(eps(eltype(mc))),
                  maxiter=10000)</code></pre><p>Compute equilibrium prices in BLP model using ζ contraction method of <a href=" https:/www.jstor.org/stable/23013173">Morrow &amp; Skerlos (2011)</a>. </p><p><strong>Arguments</strong></p><ul><li><code>mc</code> vector of <code>J</code> marginal costs</li><li><code>β</code> vector of <code>K</code> taste coefficients</li><li><code>σ</code> vector of <code>K</code> taste standard deviations</li><li><code>ξ</code> vector of <code>J</code> demand shocks</li><li><code>x</code> <code>(K-1) × J</code> exogenous product characteristics</li><li><code>ν</code> <code>K × S × T</code> array of draws of <code>ν</code></li><li><code>firmid= (1:J)</code> identifier of firm producing each good. Default value assumes each good is produced by a different firm. </li><li><code>tol</code> convergence tolerance</li><li><code>maxiter</code> maximum number of iterations.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/UBCECON567/BLPDemand.jl/blob/f8de800c2fbe03a1e330962ecaefaa924f4f887b/src/simulate.jl#LL36-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BLPDemand.estimateBLP-Tuple{Array{MarketData,1}}" href="#BLPDemand.estimateBLP-Tuple{Array{MarketData,1}}"><code>BLPDemand.estimateBLP</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">estimateBLP(dat::BLPData; method=:MPEC, verbose=true, W=I, optimizer=Ipopt.Optimizer())</code></pre><p>Estimates a random coefficients BLP demand model</p><p><strong>Arguments</strong></p><ul><li><code>dat::BLPData</code></li><li><code>method=:MPEC</code> method for estimation. Available choices are :MPEC, :NFXP, or :GEL.</li><li><code>verbose=true</code> whether to display information about optimization progress</li><li><code>W=I</code> <code>L × L</code> weighting matrix for moments. </li><li><code>optimizer=(method==:NFXP ? LBFGS(linesearch=LineSearches.HagerZhang()) :                             with_optimizer(Ipopt.Optimizer,                                            max_iter= 100,                                            start_with_resto = &quot;no&quot;,                                            print_level = 5*verbose))</code>  optimization method. See below for details.</li></ul><p><strong>Details</strong></p><p>Uses <code>L</code> unconditional moments for estimation. The moments are <code>moments[l] = 1/(T) ∑ₜ∑ⱼ (ξ[t][t]*dat[t].zd[l,j] + ω[t][j]*dat[t].zs[l,j])</code></p><p><strong>Methods</strong></p><ul><li><code>:NFXP</code> nested fixed point GMM. <code>minimize_θ G(δ(θ),θ)&#39;W G(δ(θ),θ)</code></li><li><code>:MPEC</code> constrainted GMM. <code>minimize_{θ,Δ} G(Δ, θ)&#39; W G(Δ, θ) s.t. Δ = δ(θ)</code></li><li><code>:GEL</code> constrained empiricla likelihood   <code>maximize_{p, θ, Δ} ∑ₜ log(p[t]) s.t. E_p[g(Δ, θ)] = 0 and Δ = δ(θ)</code>  For some models, there might be no feasible point for EL. This is  especially likely if the number of moments is large.</li></ul><p><strong>Optimizers</strong></p><p>If <code>method=:NFXP</code>, optimizer should be an unconstrained optimizer from the Optim.jl package. The default of <code>LBFGS()</code> is usually a good choice. <code>BFGS()</code> instead of <code>LBFGS()</code> and/or changing linesearch to <code>LineSearches.BackTracking()</code> are also worth trying.</p><p>If <code>method=:MPEC</code> or <code>:GEL</code>, the optimizer must be comptible with JuMP and capable of solving nonliner problems. The default, <code>Ipopt</code>, will occassionally fail. If <code>verbose</code> is <code>true</code> and you repeatedly see warning messages from Ipopt, then it is likely that Ipopt will run for many iterations and eventually fail to converge. Changing Ipopt&#39;s <code>start_with_reso</code> option sometimes helps. For problems of the size seen in the docs or tests, when Ipopt succeeds, it generally does so in 100 or fewer iterations. Ipopt has many additional options, see <a href="https://coin-or.github.io/Ipopt/OPTIONS.html">the Ipopt documentation</a> for a complete list.</p><p>See also: <a href="#BLPDemand.optimalIV-Tuple{Any,Any,Any,Array{MarketData,1}}"><code>optimalIV</code></a>, <a href="#BLPDemand.varianceBLP-Tuple{Any,Any,Any,Array{MarketData,1}}"><code>varianceBLP</code></a>, <a href="#BLPDemand.simulateBLP-Tuple{Any,Any,AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T,Any}"><code>simulateBLP</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/UBCECON567/BLPDemand.jl/blob/f8de800c2fbe03a1e330962ecaefaa924f4f887b/src/estimation.jl#LL346-L400">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BLPDemand.estimateRCIVlogit-Tuple{Array{MarketData,1}}" href="#BLPDemand.estimateRCIVlogit-Tuple{Array{MarketData,1}}"><code>BLPDemand.estimateRCIVlogit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">estimateRCIVlogit(dat::BLPData; method=:MPEC, verbose=true, W=I)</code></pre><p>Estimates a random coefficients IV logit model. </p><p><strong>Arguments</strong></p><ul><li><code>dat::BLPData</code></li><li><code>method=:MPEC</code> method for estimation. Available choices are :MPEC, :NFXP, or :GEL</li><li><code>verbose=true</code> whether to display information about optimization progress</li><li><code>W=I</code> weighting matrix</li></ul><p>Note that methods <code>:MPEC</code> and <code>:GEL</code> currently use a large amount of memory when <code>J</code> is large. <code>:NFXP</code> may be preferrable in this situation. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/UBCECON567/BLPDemand.jl/blob/f8de800c2fbe03a1e330962ecaefaa924f4f887b/src/estimation.jl#LL198-L212">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BLPDemand.fracRCIVlogit-Tuple{Array{MarketData,1}}" href="#BLPDemand.fracRCIVlogit-Tuple{Array{MarketData,1}}"><code>BLPDemand.fracRCIVlogit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fracblp(dat::BLPData)</code></pre><p>Estimate random coefficients IV model using &quot;Fast, Robust, Approximately Correct&quot; method of Salanie &amp; Wolak (2019)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/UBCECON567/BLPDemand.jl/blob/f8de800c2fbe03a1e330962ecaefaa924f4f887b/src/estimation.jl#LL771-L775">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BLPDemand.makeivblp-Tuple{AbstractArray{T,2} where T}" href="#BLPDemand.makeivblp-Tuple{AbstractArray{T,2} where T}"><code>BLPDemand.makeivblp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">makeivblp(x::AbstractMatrix, firmid=1:size(x,2))</code></pre><p>Function for constructing demand instrumental variables following BLP (1995).</p><p>Instruments consist of exogenous product characteristics, sum of rivals exogenous characteristics, and, if there are any multi-product firms, sum of characteristics of other goods produced by the same firm.</p><p>If includeexp is true, then also use  <code>sum(exp(-([x[2:end,j,t] - x[l,j,t])^2) for l in 1:J))</code> as instruments. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/UBCECON567/BLPDemand.jl/blob/f8de800c2fbe03a1e330962ecaefaa924f4f887b/src/estimation.jl#LL94-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BLPDemand.makeivblp-Tuple{Array{MarketData,1}}" href="#BLPDemand.makeivblp-Tuple{Array{MarketData,1}}"><code>BLPDemand.makeivblp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">makeivblp(dat::BLPData; includeexp=true)</code></pre><p>Sets dat[:].zd and dat[:].zs to makeivblp([x[2:end,:] w])</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/UBCECON567/BLPDemand.jl/blob/f8de800c2fbe03a1e330962ecaefaa924f4f887b/src/estimation.jl#LL149-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BLPDemand.optimalIV-Tuple{Any,Any,Any,Array{MarketData,1}}" href="#BLPDemand.optimalIV-Tuple{Any,Any,Any,Array{MarketData,1}}"><code>BLPDemand.optimalIV</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">optimalIV(β, σ, γ, dat::BLPData ; degree=2)</code></pre><p>Computes optimal instruments for BLP model. Given initial estimates θ=(<code>β</code>, <code>σ</code>, <code>γ</code>), computes <code>e(θ)ⱼₜ = (ξ(θ)ⱼₜ , ω(θ)ⱼₜ)</code>, and then approximates the optimal instruments with a polynomial regression of <code>degree</code> of  <code>∂e/∂θ</code> on <code>z</code>. Returns BLPData with instruments set to fitted values <code>(zd, zs) = (E[∂ξ/∂θ|z], E[∂ω/∂θ|z])</code>  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/UBCECON567/BLPDemand.jl/blob/f8de800c2fbe03a1e330962ecaefaa924f4f887b/src/estimation.jl#LL728-L735">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BLPDemand.pack-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}" href="#BLPDemand.pack-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}"><code>BLPDemand.pack</code></a> — <span class="docstring-category">Method</span></header><section><div><p>pack(β::AbstractVector, σ::AbstractVector, ...)</p><p>Packs parameters into a single vector, θ.</p><p>Returns tuple with the packed parameters, θ, and a function to unpack them, i.e.</p><pre><code class="language-none">unpack(θ) = (β, σ, ...)</code></pre><p>and</p><pre><code class="language-none">pack(unpack(θ)) = θ</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/UBCECON567/BLPDemand.jl/blob/f8de800c2fbe03a1e330962ecaefaa924f4f887b/src/estimation.jl#LL166-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BLPDemand.share-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,2} where T,AbstractArray{T,2} where T}" href="#BLPDemand.share-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,2} where T,AbstractArray{T,2} where T}"><code>BLPDemand.share</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function share(δ::AbstractVector, σ::AbstractVector, x::AbstractMatrix, ν::AbstractMatrix)</code></pre><p>Compute market shares in BLP random coefficients demand model.</p><p>Market shares are given by </p><div>\[ s_{j} = \int \frac{e^{\delta_j + x_j σ ν}}{1+\sum_{i=1}^J e^{\delta_i + x_i σ ν}} dF_ν(ν)\]</div><p><strong>Arguments:</strong></p><ul><li><code>δ</code> vector of length <code>J=</code> number of products</li><li><code>σ</code> vector of length <code>K=</code> number of characteristics</li><li><code>x</code> <code>K × J</code> matrix of product characteristics</li><li><code>ν</code> <code>K × S</code> matrix of simulation draws for integration</li></ul><p>Returns vector of length <code>J</code> market shares. </p><p>See also: <a href="#BLPDemand.delta-Union{Tuple{T}, Tuple{AbstractArray{T,1},AbstractArray{T,2},AbstractArray{T,2},AbstractArray{T,1}}} where T"><code>delta</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/UBCECON567/BLPDemand.jl/blob/f8de800c2fbe03a1e330962ecaefaa924f4f887b/src/share.jl#LL2-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BLPDemand.sharep-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,2} where T,AbstractArray{T,2} where T,AbstractArray{T,1} where T}" href="#BLPDemand.sharep-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,2} where T,AbstractArray{T,2} where T,AbstractArray{T,1} where T}"><code>BLPDemand.sharep</code></a> — <span class="docstring-category">Method</span></header><section><div><p>function sharep(β::AbstractVector,                    σ::AbstractVector,                    p::AbstractVector,                    x::AbstractMatrix,                    ν::AbstractMatrix,                    ξ::AbstractVector)</p><p>Compute market shares in BLP random coefficients demand model.</p><p>Market shares are given by </p><div>\[ s_{j} = \int \frac{e^{\delta_j + x_j σ ν}}{1+\sum_{i=1}^J e^{\delta_i + x_i σ ν}} dF_ν(ν)\]</div><p>where </p><div>\[\delta_j = β[1]*p[j] + x[:,j]&#39; *β[2:end] + ξ[j]\]</div><p><strong>Arguments:</strong></p><ul><li><code>β</code> vector of length <code>K=</code> number of characteristics</li><li><code>σ</code> vector of length <code>K=</code> number of characteristics</li><li><code>p</code> <code>J</code> vector of prices</li><li><code>x</code> <code>(K-1) × J</code> matrix of exogenous product characteristics</li><li><code>ν</code> <code>K × S</code> matrix of simulation draws for integration</li><li><code>ξ</code> <code>J</code> vector of demand shocks</li></ul><p>Returns vector of length <code>J</code> market shares. </p><p>See also: <a href="@ref"><code>share</code>, <code>dsharedp</code></a>  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/UBCECON567/BLPDemand.jl/blob/f8de800c2fbe03a1e330962ecaefaa924f4f887b/src/share.jl#LL51-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BLPDemand.simulateBLP-Tuple{Any,Any,AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T,Any}" href="#BLPDemand.simulateBLP-Tuple{Any,Any,AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T,Any}"><code>BLPDemand.simulateBLP</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function simulateBLP(J, T, β, σ, γ, S; varξ=1, varω=1, randj=1.0, firmid=1:J)</code></pre><p>Simulates a BLP demand and supply model.</p><p><strong>Arguments</strong></p><ul><li><code>J</code> numebr of products</li><li><code>T::Integer</code> number of markets</li><li><code>β::AbstractVector</code> with <code>length(β)=K</code>, average tastes for characteristics. The first characteristic will be endogeneous (price)</li><li><code>σ::AbstractVector</code> with <code>length(σ)=K</code>, standard deviation of tastes for characteristics</li><li><code>γ::AbstractVector</code> marginal cost coefficients</li><li><code>S</code> number of simulation draws to calculate market shares</li><li><code>varξ=1</code> standard deviation of ξ</li><li><code>varω=1</code> standard deviation of ω</li><li><code>randj=1.0</code> if less than 1, then J is the maximum number of products per market. Each product is included in each market with probability randj</li><li><code>firmid=1:J</code> firm identifiers. Must be length J. </li></ul><p><strong>Returns</strong></p><ul><li><code>dat</code> a <a href="#BLPDemand.BLPData"><code>BLPData</code></a> struct</li><li><code>ξ</code></li><li><code>ω</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/UBCECON567/BLPDemand.jl/blob/f8de800c2fbe03a1e330962ecaefaa924f4f887b/src/simulate.jl#LL93-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BLPDemand.simulateIVRClogit-NTuple{6,Any}" href="#BLPDemand.simulateIVRClogit-NTuple{6,Any}"><code>BLPDemand.simulateIVRClogit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function simulateIVRClogit(T, β, σ, π, ρ, S)</code></pre><p>Simulates a random coefficients logit model with endogeneity.</p><p><strong>Arguments</strong></p><ul><li><code>T::Integer</code> number of markets</li><li><code>β::AbstractVector</code> with <code>length(β)=K</code>, average tastes for characteristics.</li><li><code>σ::AbstractVector</code> with <code>length(σ)=K</code>, standard deviation of tastes for characteristics</li><li><code>π::AbstractMatrix</code> with <code>size(π) = (L, K, J)</code>, first stage coefficients</li><li><code>ρ::Number</code> strength of endogeneity</li><li><code>S</code> number of simulation draws to calculate market shares</li></ul><p>Returns <a href="#BLPDemand.BLPData"><code>BLPData</code></a> struct</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/UBCECON567/BLPDemand.jl/blob/f8de800c2fbe03a1e330962ecaefaa924f4f887b/src/simulate.jl#LL1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BLPDemand.supplymoments-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T,Array{MarketData,1}}" href="#BLPDemand.supplymoments-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T,Array{MarketData,1}}"><code>BLPDemand.supplymoments</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">supplymoments(γ::AbstractVector, β::AbstractVector, σ::AbstractVector,
                   ξ::AbstractVector, dat::BLPData)</code></pre><p>Supply side moments in a BLP model. Assumes that marginal cost is log linear, </p><div>\[c_{jt} = \exp(w_{jt}&#39;γ + ω_{jt})\]</div><p>and prices are Bertrand-Nash</p><div>\[c_{t} = p_{t} + (∂s/∂p)^{-1} s\]</div><p>where <code>∂s/∂p</code> is the Jacobian of shares with respect to prices, but with the <code>j,l</code> entry set to zero unless goods <code>j</code> and <code>l</code> are produced by the same firm. </p><p><strong>Arguments</strong></p><ul><li><code>γ</code> marginal cost coefficients</li><li><code>β</code> length <code>K</code> (=number characteristics) vector of average tastes for characteristics</li><li><code>σ</code> length <code>K</code> vector of standard deviations of tastes</li><li><code>ξ</code> <code>J × T</code> matrix of market demand shocks</li><li><code>dat::BLPData</code> </li></ul><p>Returns <code>(moments, ω)</code> an <code>L</code> vector of moments with <code>moments[l] = 1/(T) ∑ₜ∑ⱼ ω[t][j]*dat[t].zs[l,j]</code> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/UBCECON567/BLPDemand.jl/blob/f8de800c2fbe03a1e330962ecaefaa924f4f887b/src/estimation.jl#LL44-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BLPDemand.varianceBLP-Tuple{Any,Any,Any,Array{MarketData,1}}" href="#BLPDemand.varianceBLP-Tuple{Any,Any,Any,Array{MarketData,1}}"><code>BLPDemand.varianceBLP</code></a> — <span class="docstring-category">Method</span></header><section><div><p>varianceBLP(β, σ, γ, dat::BLPData ; W=I)  </p><p>Computes variance of BLP estimates. Computes moment variance clustering on <code>t</code>. </p><p>Returns <code>Σ</code> = covariance of <code>[β, σ, γ]</code> and <code>varm</code> = (clustered) covariance of moments.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/UBCECON567/BLPDemand.jl/blob/f8de800c2fbe03a1e330962ecaefaa924f4f887b/src/estimation.jl#LL630-L636">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BLPDemand.polyreg-Tuple{AbstractArray{T,2} where T,AbstractArray{T,2} where T,AbstractArray{T,2} where T}" href="#BLPDemand.polyreg-Tuple{AbstractArray{T,2} where T,AbstractArray{T,2} where T,AbstractArray{T,2} where T}"><code>BLPDemand.polyreg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">  polyreg(xpred::AbstractMatrix,
          xdata::AbstractMatrix,
          ydata::AbstractMatrix; degree=1)</code></pre><p>Computes  polynomial regression of ydata on xdata. Returns predicted y at x=xpred. </p><p><strong>Arguments</strong></p><ul><li><code>xpred</code> x values to compute fitted y</li><li><code>xdata</code> observed x</li><li><code>ydata</code> observed y, must have <code>size(y)[1] == size(xdata)[1]</code></li><li><code>degree</code></li><li><code>deriv</code> whether to also return df(xpred). Only implemented when  xdata is one dimentional</li></ul><p><strong>Returns</strong></p><ul><li>Estimates of <code>f(xpred)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/UBCECON567/BLPDemand.jl/blob/f8de800c2fbe03a1e330962ecaefaa924f4f887b/src/estimation.jl#LL666-L686">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BLPDemand.varianceRCIVlogit-Tuple{Any,Any,Array{MarketData,1}}" href="#BLPDemand.varianceRCIVlogit-Tuple{Any,Any,Array{MarketData,1}}"><code>BLPDemand.varianceRCIVlogit</code></a> — <span class="docstring-category">Method</span></header><section><div><p>varianceRCIVlogit(β, σ, dat::BLPData ; W=I)  </p><p>Computes variance of RCIVlogit estimates. Computes moment variance clustering on <code>t</code>. </p><p>Returns <code>Σ</code> = covariance of <code>[β, σ, γ]</code> and <code>varm</code> = (clustered) covariance of moments.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/UBCECON567/BLPDemand.jl/blob/f8de800c2fbe03a1e330962ecaefaa924f4f887b/src/estimation.jl#LL597-L603">source</a></section></article><h2 id="Index-1"><a class="docs-heading-anchor" href="#Index-1">Index</a><a class="docs-heading-anchor-permalink" href="#Index-1" title="Permalink"></a></h2><ul><li><a href="#BLPDemand.BLPData-Tuple{AbstractArray{T,2} where T,AbstractArray{T,3} where T,AbstractArray{T,3} where T,AbstractArray{T,3} where T,AbstractArray{T,3} where T,AbstractArray{T,3} where T}"><code>BLPDemand.BLPData</code></a></li><li><a href="#BLPDemand.BLPData-Tuple{AbstractArray{T,2} where T,AbstractArray{T,3} where T,AbstractArray{T,3} where T,AbstractArray{T,3} where T}"><code>BLPDemand.BLPData</code></a></li><li><a href="#BLPDemand.BLPData"><code>BLPDemand.BLPData</code></a></li><li><a href="#BLPDemand.BLPData-Tuple{DataFrames.DataFrame,Symbol,Symbol,Symbol,Array{Symbol,1},Array{Symbol,1},Array{Symbol,1},Array{Symbol,1},AbstractArray{T,3} where T}"><code>BLPDemand.BLPData</code></a></li><li><a href="#BLPDemand.MarketData"><code>BLPDemand.MarketData</code></a></li><li><a href="#BLPDemand.data_blp1999-Tuple{}"><code>BLPDemand.data_blp1999</code></a></li><li><a href="#BLPDemand.delta-Union{Tuple{T}, Tuple{AbstractArray{T,1},AbstractArray{T,2},AbstractArray{T,2},AbstractArray{T,1}}} where T"><code>BLPDemand.delta</code></a></li><li><a href="#BLPDemand.demandmoments-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T,Array{MarketData,1}}"><code>BLPDemand.demandmoments</code></a></li><li><a href="#BLPDemand.dsharedp-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,2} where T,AbstractArray{T,2} where T,AbstractArray{T,1} where T}"><code>BLPDemand.dsharedp</code></a></li><li><a href="#BLPDemand.eqprices-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,2} where T,AbstractArray{T,2} where T}"><code>BLPDemand.eqprices</code></a></li><li><a href="#BLPDemand.estimateBLP-Tuple{Array{MarketData,1}}"><code>BLPDemand.estimateBLP</code></a></li><li><a href="#BLPDemand.estimateRCIVlogit-Tuple{Array{MarketData,1}}"><code>BLPDemand.estimateRCIVlogit</code></a></li><li><a href="#BLPDemand.fracRCIVlogit-Tuple{Array{MarketData,1}}"><code>BLPDemand.fracRCIVlogit</code></a></li><li><a href="#BLPDemand.makeivblp-Tuple{AbstractArray{T,2} where T}"><code>BLPDemand.makeivblp</code></a></li><li><a href="#BLPDemand.makeivblp-Tuple{Array{MarketData,1}}"><code>BLPDemand.makeivblp</code></a></li><li><a href="#BLPDemand.optimalIV-Tuple{Any,Any,Any,Array{MarketData,1}}"><code>BLPDemand.optimalIV</code></a></li><li><a href="#BLPDemand.pack-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}"><code>BLPDemand.pack</code></a></li><li><a href="#BLPDemand.polyreg-Tuple{AbstractArray{T,2} where T,AbstractArray{T,2} where T,AbstractArray{T,2} where T}"><code>BLPDemand.polyreg</code></a></li><li><a href="#BLPDemand.share-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,2} where T,AbstractArray{T,2} where T}"><code>BLPDemand.share</code></a></li><li><a href="#BLPDemand.sharep-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,2} where T,AbstractArray{T,2} where T,AbstractArray{T,1} where T}"><code>BLPDemand.sharep</code></a></li><li><a href="#BLPDemand.simulateBLP-Tuple{Any,Any,AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T,Any}"><code>BLPDemand.simulateBLP</code></a></li><li><a href="#BLPDemand.simulateIVRClogit-NTuple{6,Any}"><code>BLPDemand.simulateIVRClogit</code></a></li><li><a href="#BLPDemand.supplymoments-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T,Array{MarketData,1}}"><code>BLPDemand.supplymoments</code></a></li><li><a href="#BLPDemand.varianceBLP-Tuple{Any,Any,Any,Array{MarketData,1}}"><code>BLPDemand.varianceBLP</code></a></li><li><a href="#BLPDemand.varianceRCIVlogit-Tuple{Any,Any,Array{MarketData,1}}"><code>BLPDemand.varianceRCIVlogit</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../simulation/">« Simulations</a><a class="docs-footer-nextpage" href="../implementation/">Developer Notes »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 13 February 2020 01:37">Thursday 13 February 2020</span>. Using Julia version 1.3.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
