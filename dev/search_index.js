var documenterSearchIndex = {"docs":
[{"location":"functions/#Function-Reference-1","page":"Function Reference","title":"Function Reference","text":"","category":"section"},{"location":"functions/#","page":"Function Reference","title":"Function Reference","text":"Modules = [BLPDemand]","category":"page"},{"location":"functions/#BLPDemand.delta-Union{Tuple{T}, Tuple{AbstractArray{T,1},AbstractArray{T,2},AbstractArray{T,2},AbstractArray{T,1}}} where T","page":"Function Reference","title":"BLPDemand.delta","text":"function delta(s, x, ν, σ;                 tol=sqrt(eps(eltype(s))), maxiter=1000)\n\nSolves for δ in s = share(δ, ...) using contraction mapping iteration.\n\nSee also: share\n\n\n\n\n\n","category":"method"},{"location":"functions/#BLPDemand.demandmoments-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,2} where T,Any,Any,Any}","page":"Function Reference","title":"BLPDemand.demandmoments","text":"function demandmoments(β::AbstractVector,σ::AbstractVector,\n                       s::AbstractMatrix, \n                       x, ν, ivdemand)\n\nDemand side moments in BLP model. \n\nArguments\n\nβ length K (=number characteristics) vector of average tastes for characteristics\nσ length K vector of standard deviations of tastes\ns J × T matrix of market shares\nx K × J × T array of product characteristics\nν K × S × T array of draws of ν\nivdemand L × J × T array of instruments. Identification requries L ≥ K.\n\nReturns (moments, ξ) where vector of moments is length L with moments[l] = 1/(JT) ∑ⱼ∑ₜ ξ[j,t]*ivdemands[l,j,t]\n\nSee also: share, delta, simulateRCIVlogit\n\n\n\n\n\n","category":"method"},{"location":"functions/#BLPDemand.dsharedp-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,2} where T,AbstractArray{T,2} where T,AbstractArray{T,1} where T}","page":"Function Reference","title":"BLPDemand.dsharedp","text":"function dsharedp(β::AbstractVector,\n              σ::AbstractVector,\n              p::AbstractVector,\n              x::AbstractMatrix,\n              ν::AbstractMatrix,\n              ξ::AbstractVector)\n\nCompute market shares and their derivatives in BLP random coefficients demand model.\n\nSee sharep for argument details.\n\nReturns\n\ns vector J market shares\nds J × J Jacobian matrix with ds[l,j] = ∂s[l]/∂p[j]\nΛ J × J diagonal matrix with ds = Λ - Γ\nΓ J × J matrix \n\nSee eqprices for usage of Λ and Γ.    \n\n\n\n\n\n","category":"method"},{"location":"functions/#BLPDemand.eqprices-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T,Any,Any}","page":"Function Reference","title":"BLPDemand.eqprices","text":"function eqprices(mc::AbstractVector,\n                  β::AbstractVector, σ::AbstractVector,\n                  ξ::AbstractVector,\n                  x, ν;\n                  firmid= 1:length(mc),\n                  tol=sqrt(eps(eltype(mc))),\n                  maxiter=10000)\n\nCompute equilibrium prices in BLP model using ζ contraction method of Morrow & Skerlos (2011). \n\nArguments\n\nmc vector of J marginal costs\nβ vector of K taste coefficients\nσ vector of K taste standard deviations\nξ vector of J demand shocks\nx (K-1) × J exogenous product characteristics\nν K × S × T array of draws of ν\nfirmid= (1:J) identifier of firm producing each good. Default value assumes each good is produced by a different firm. \ntol convergence tolerance\nmaxiter maximum number of iterations.\n\n\n\n\n\n","category":"method"},{"location":"functions/#BLPDemand.estimateBLP-Tuple{AbstractArray{T,2} where T,AbstractArray{T,3} where T,AbstractArray{T,3} where T,AbstractArray{T,3} where T,AbstractArray{T,3} where T,AbstractArray{T,3} where T}","page":"Function Reference","title":"BLPDemand.estimateBLP","text":"estimateBLP(s, x, ν, ivdemand, w, ivsupply; method=:MPEC, verbose=true, firmid, W)\n\nEstimates a random coefficients BLP demand model\n\nArguments\n\ns J × T matrix of market shares\nx K × J × T array of product characteristics. First one must be price.\nν K × S × T array of draws for Monte Carlo integration\nivdemand L × J × T array of instruments\nw `C × J × Tarray of cost shifters\nivsupply L × J × T array of instruments. Identification requires L ≥ 2K + C\nmethod=:MPEC method for estimation. Available choices are :MPEC, :NFXP, or :GEL.\nverbose=true whether to display information about optimization progress\nfirmid J vector of firm identifies. Default value corresponds to J single product firms.\nW=I L × L weighting matrix for moments. \n\nDetails\n\nUses L unconditional moments for estimation the moments are moments[l] = 1/(JT) ∑ⱼ∑ₜ (ξ[j,t]*ivdemands[l,j,t] + ω[j,t]*ivsupply[l,j,t])\n\nMethods\n\n:NFXP nested fixed point GMM. minimize_θ G(δ(θ),θ)'W G(δ(θ),θ)\n:MPEC constrainted GMM. minimize_{θ,Δ} G(Δ, θ)' W G(Δ, θ) s.t. Δ = δ(θ)\n:GEL constrained GEL maximize_{p, θ, Δ} ∑ₜ log(p[t]) s.t. E_p[g(Δ, θ)] = 0 and Δ = δ(θ)\n\nSee also: optimalIV, varianceBLP, simulateBLP\n\n\n\n\n\n","category":"method"},{"location":"functions/#BLPDemand.estimateRCIVlogit-NTuple{4,Any}","page":"Function Reference","title":"BLPDemand.estimateRCIVlogit","text":"estimateRCIVlogit(s, x, ν, iv, method=:MPEC)\n\nEstimates a random coefficients IV logit model. \n\nArguments\n\ns J × T matrix of market shares\nx K × J × T array of product characteristics\nν K × S × T array of draws for MC integration\niv L × J × T array of instruments\nmethod method for estimation. Available choices are :MPEC or :NFXP.\nverbose whether to display information about optimization progress\n\n\n\n\n\n","category":"method"},{"location":"functions/#BLPDemand.makeivblp","page":"Function Reference","title":"BLPDemand.makeivblp","text":"function makeivblp(x::AbstractMatrix, firmid=1:size(x,2))\n\nFunction for constructing demand instrumental variables following BLP (1995).\n\nInstruments consist of exogenous product characteristics, sum of rivals exogenous characteristics, and, if there are any multi-product firms, sum of characteristics of other goods produced by the same firm.\n\n\n\n\n\n","category":"function"},{"location":"functions/#BLPDemand.optimalIV-Tuple{Any,Any,Any,AbstractArray{T,2} where T,AbstractArray{T,3} where T,AbstractArray{T,3} where T,AbstractArray{T,3} where T,AbstractArray{T,3} where T}","page":"Function Reference","title":"BLPDemand.optimalIV","text":"optimalIV(β,σ, γ, \n          s::AbstractMatrix,\n          x::AbstractArray{T, 3} where T, ν::AbstractArray{T,3} where T,\n          z::AbstractArray{T,3} where T, w::AbstractArray{T, 3} where T;\n          firmid=1:size(s,1), degree=2)\n\nComputes optimal instruments for BLP model. Given initial estimates θ=(β, σ, γ), computes e(θ)ⱼₜ = (ξ(θ)ⱼₜ , ω(θ)ⱼₜ), and then approximates the optimal instruments with a polynomial regression of degree of  ∂e/∂θ on z. Returns fitted values (zd, zs) = (E[∂ξ/∂θ|z], E[∂ω/∂θ|z])  \n\n\n\n\n\n","category":"method"},{"location":"functions/#BLPDemand.pack-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}","page":"Function Reference","title":"BLPDemand.pack","text":"pack(β::AbstractVector, σ::AbstractVector, ...)\n\nPacks parameters into a single vector, θ.\n\nReturns tuple with the packed parameters, θ, and a function to unpack them, i.e.\n\nunpack(θ) = (β, σ, ...)\n\nand\n\npack(unpack(θ)) = θ\n\n\n\n\n\n","category":"method"},{"location":"functions/#BLPDemand.share-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,2} where T,AbstractArray{T,2} where T}","page":"Function Reference","title":"BLPDemand.share","text":"function share(δ::AbstractVector, σ::AbstractVector, x::AbstractMatrix, ν::AbstractMatrix)\n\nCompute market shares in BLP random coefficients demand model.\n\nMarket shares are given by \n\n s_j = int frace^delta_j + x_j σ ν1+sum_i=1^J e^delta_i + x_i σ ν dF_ν(ν)\n\nArguments:\n\nδ vector of length J= number of products\nσ vector of length K= number of characteristics\nx K × J matrix of product characteristics\nν K × S matrix of simulation draws for integration\n\nReturns vector of length J market shares. \n\nSee also: delta\n\n\n\n\n\n","category":"method"},{"location":"functions/#BLPDemand.sharep-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,2} where T,AbstractArray{T,2} where T,AbstractArray{T,1} where T}","page":"Function Reference","title":"BLPDemand.sharep","text":"function sharep(β::AbstractVector,                    σ::AbstractVector,                    p::AbstractVector,                    x::AbstractMatrix,                    ν::AbstractMatrix,                    ξ::AbstractVector)\n\nCompute market shares in BLP random coefficients demand model.\n\nMarket shares are given by \n\n s_j = int frace^delta_j + x_j σ ν1+sum_i=1^J e^delta_i + x_i σ ν dF_ν(ν)\n\nwhere \n\ndelta_j = β1*pj + xj *β2end + ξj\n\nArguments:\n\nβ vector of length K= number of characteristics\nσ vector of length K= number of characteristics\np J vector of prices\nx (K-1) × J matrix of exogenous product characteristics\nν K × S matrix of simulation draws for integration\nξ J vector of demand shocks\n\nReturns vector of length J market shares. \n\nSee also: share, dsharedp  \n\n\n\n\n\n","category":"method"},{"location":"functions/#BLPDemand.simulateBLP-Tuple{Any,Any,AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T,Any}","page":"Function Reference","title":"BLPDemand.simulateBLP","text":"function simulateBLP(T, β, σ, γ, S)\n\nSimulates a BLP demand and supply model.\n\nArguments\n\nT::Integer number of markets\nβ::AbstractVector with length(β)=K, average tastes for characteristics. The first characteristic will be endogeneous (price)\nσ::AbstractVector with length(σ)=K, standard deviation of tastes for characteristics\nγ::AbstractVector marginal cost coefficients\nS number of simulation draws to calculate market shares\n\nReturns\n\nx array of product characteristics with size(x) = (K, J, T)\nz array of instruments with size(z) = (L, J, T)\ns matrix of market shares size(s) = (J,T)\nν random draws used to compute market shares, size(ν) = (K,S,T). log(-ν[1,:,:]) is N(0,1) the other components of ν are N(0,1). It is important that β[1] + σ[1]*ν[1,:,:] is negative.\nξ market demand shocks, size(ξ) = (J,T)\n\n\n\n\n\n","category":"method"},{"location":"functions/#BLPDemand.simulateIVRClogit-NTuple{6,Any}","page":"Function Reference","title":"BLPDemand.simulateIVRClogit","text":"function simulateIVRClogit(T, β, σ, π, ρ, S)\n\nSimulates a random coefficients logit model with endogeneity.\n\nArguments\n\nT::Integer number of markets\nβ::AbstractVector with length(β)=K, average tastes for characteristics.\nσ::AbstractVector with length(σ)=K, standard deviation of tastes for characteristics\nπ::AbstractMatrix with size(π) = (L, K, J), first stage coefficients\nρ::Number strength of endogeneity\nS number of simulation draws to calculate market shares\n\nReturns\n\nx array of product characteristics with size(x) = (K, J, T)\nz array of instruments with size(z) = (L, J, T)\ns matrix of market shares size(s) = (J,T)\nν random draws used to compute market shares, size(ν) = (K,S,T)\nξ market demand shocks, size(ξ) = (J,T)\n\n\n\n\n\n","category":"method"},{"location":"functions/#BLPDemand.supplymoments-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,2} where T,Any,Any,Any,Any}","page":"Function Reference","title":"BLPDemand.supplymoments","text":"function supplymoments(γ::AbstractVector, β::AbstractVector, σ::AbstractVector,\n                       ξ::AbstractVector, x, ν, w, ivsupply; \n                       firmid= (1:size(ξ,1)) .* fill(1, size(ξ,2))')\n\nSupply side moments in a BLP model. Assumes that marginal cost is log linear, \n\nc_jt = exp(w_jtγ + ω_jt)\n\nand prices are Bertrand-Nash\n\nc_t = p_t + (sp)^-1 s\n\nwhere ∂s/∂p is the Jacobian of shares with respect to prices, but with the j,l entry set to zero unless goods j and l are produced by the same firm. \n\nArguments\n\nγ marginal cost coefficients\nβ length K (=number characteristics) vector of average tastes for characteristics\nσ length K vector of standard deviations of tastes\nξ J × T matrix of market demand shocks\nx K × J × T array of product characteristics\nν K × S × T array of draws of ν\nw length(γ) × J × T array of cost shifters\nivsupply M × J × T array of instruments. Identification requries M ≥ length(γ).\nfirmid= (1:J) .* fill(1, T)' identifier of firm producing each good. Default value assumes each good is produced by a different firm. \n\nReturns (moments, ω) an L vector of moments with moments[l] = 1/(JT) ∑ⱼ∑ₜ ω[j,t]*ivsupply[l,j,t] \n\n\n\n\n\n","category":"method"},{"location":"functions/#BLPDemand.varianceBLP-Tuple{Any,Any,Any,AbstractArray{T,2} where T,AbstractArray{T,3} where T,AbstractArray{T,3} where T,AbstractArray{T,3} where T,AbstractArray{T,3} where T,AbstractArray{T,3} where T}","page":"Function Reference","title":"BLPDemand.varianceBLP","text":"varianceBLP(β, σ, γ, s::AbstractMatrix,                      x::AbstractArray{T, 3} where T, ν::AbstractArray{T,3} where T,                      ivdemand::AbstractArray{T,3} where T,                      w::AbstractArray{T, 3} where T, ivsupply::AbstractArray{T, 3} where T;                      firmid=1:size(s,1), W=I)  \n\nComputes variance of BLP estimates. Computes moment variance clustering on t. \n\nReturns Σ = covariance of [β, σ, γ] and varm = (clustered) covariance of moments.  \n\n\n\n\n\n","category":"method"},{"location":"functions/#BLPDemand.loadblpdata-Tuple{}","page":"Function Reference","title":"BLPDemand.loadblpdata","text":"function loadblpdata()\n\nLoads data from Berry, Levinsohn, and Pakes (1999).\n\nReturns a DataFrame.\n\n\n\n\n\n","category":"method"},{"location":"functions/#BLPDemand.polyreg-Tuple{AbstractArray{T,2} where T,AbstractArray{T,2} where T,AbstractArray{T,2} where T}","page":"Function Reference","title":"BLPDemand.polyreg","text":"  polyreg(xpred::AbstractMatrix,\n          xdata::AbstractMatrix,\n          ydata::AbstractMatrix; degree=1)\n\nComputes  polynomial regression of ydata on xdata. Returns predicted y at x=xpred. \n\nArguments\n\nxpred x values to compute fitted y\nxdata observed x\nydata observed y, must have size(y)[1] == size(xdata)[1]\ndegree\nderiv whether to also return df(xpred). Only implemented when  xdata is one dimentional\n\nReturns\n\nEstimates of f(xpred)\n\n\n\n\n\n","category":"method"},{"location":"functions/#Index-1","page":"Function Reference","title":"Index","text":"","category":"section"},{"location":"functions/#","page":"Function Reference","title":"Function Reference","text":"","category":"page"},{"location":"simulation/#Simulations-1","page":"Simulations","title":"Simulations","text":"","category":"section"},{"location":"simulation/#","page":"Simulations","title":"Simulations","text":"Here we perform some monte-carlo simulations to illustrute package usage and estimator performance. See Model for an overview of the model. The tests directory contains some additional examples.","category":"page"},{"location":"simulation/#Generate-Data-1","page":"Simulations","title":"Generate Data","text":"","category":"section"},{"location":"simulation/#","page":"Simulations","title":"Simulations","text":"using BLPDemand, Statistics, PrettyTables, Printf\nK = 3             # number of characteristics\nJ = 5             # number of products\nS = 20            # draws of nu\nT = 100           # number of markets\nβ = ones(K)*2 \nβ[1] = -1.5       # important for equilibrium that higher prices lower sales\nσ = ones(K)*0.2\nγ = ones(2)*0.3\n\n(x, w, p, s, ν, ξ, ω) = simulateBLP(J,T, β, σ, γ, S, varξ=0.2, varω=0.2)\n@show quantile(s[:], [0, 0.05, 0.5, 0.95, 1])","category":"page"},{"location":"simulation/#","page":"Simulations","title":"Simulations","text":"Estimation will encounter numerical difficulties if market shares are very close (within 1e-4) to 0 or 1. The above range should be fine. ","category":"page"},{"location":"simulation/#Instruments-1","page":"Simulations","title":"Instruments","text":"","category":"section"},{"location":"simulation/#","page":"Simulations","title":"Simulations","text":"In the simulated data x[2:end,:,:] and w are uncorrelated with ξ and ω, but price, x[1,:,:], is endogenous. The price of the jth firm will depend on the characteristics and costs of all other goods, so these are available as instruments. makeivblp is a convenience function that constructs the sum of all other firms' exogenous variables to use as instruments. This is similar to what Berry, Levinsohn, and Pakes (1995) do. We will see below though that much more accurate estimates can be obtained by using the optimal instruments. ","category":"page"},{"location":"simulation/#","page":"Simulations","title":"Simulations","text":"z = makeivblp(cat(x[2:end,:,:], w, dims=1));\nsize(z)","category":"page"},{"location":"simulation/#Estimation-1","page":"Simulations","title":"Estimation","text":"","category":"section"},{"location":"simulation/#","page":"Simulations","title":"Simulations","text":"We can now estimate the model. Three methods are available: GMM with nested-fixed point (:NFXP), constrained GMM (:MPEC), and constrained GEL (:GEL). See estimateBLP. ","category":"page"},{"location":"simulation/#","page":"Simulations","title":"Simulations","text":"@time nfxp = estimateBLP(s, x, ν, z, w, z, method=:NFXP, verbose=false)\n@time mpec = estimateBLP(s, x, ν, z, w, z, method=:MPEC,verbose=true);\n@time gel = estimateBLP(s, x, ν, z, w, z, method=:GEL,verbose=true);","category":"page"},{"location":"simulation/#","page":"Simulations","title":"Simulations","text":"tbl = vcat([\"\" \"True\" \"NFXP\" \"MPEC\" \"GEL\"],\n           [(i->\"β[$i]\").(1:length(β)) β nfxp.β mpec.β gel.β],\n           [(i->\"σ[$i]\").(1:length(σ)) σ nfxp.σ mpec.σ gel.σ],\n           [(i->\"γ[$i]\").(1:length(γ)) γ nfxp.γ mpec.γ gel.γ])\npretty_table(tbl, noheader=true, formatter=ft_printf(\"%6.3f\",3:5))","category":"page"},{"location":"simulation/#","page":"Simulations","title":"Simulations","text":"In the absence of optimization error and other numeric problems, :NFXP and :MPEC should produce identical results.  In finite sample, we should expect the GEL estimates to differ. All three methods are consistent, but GEL is also asymptotically efficient (for a fixed choice of z; different z can have large effects on efficiency).","category":"page"},{"location":"simulation/#Inference-1","page":"Simulations","title":"Inference","text":"","category":"section"},{"location":"simulation/#","page":"Simulations","title":"Simulations","text":"varianceBLP computes the variance of the estimates produced by either of GMM estimation methods. ","category":"page"},{"location":"simulation/#","page":"Simulations","title":"Simulations","text":"vnfxp = varianceBLP(nfxp.β, nfxp.σ, nfxp.γ, s, x, ν, z, w, z);\nvmpec = varianceBLP(mpec.β, mpec.σ, mpec.γ, s, x, ν, z, w, z);\nnothing","category":"page"},{"location":"simulation/#","page":"Simulations","title":"Simulations","text":"Inference for GEL has not been directly implemented. However, GEL is first order asymptotically equivalent to efficiently weigthed GMM. In other words, GEL estimates have the same asymptotic variance as efficiently weighted GMM. ","category":"page"},{"location":"simulation/#","page":"Simulations","title":"Simulations","text":"v = varianceBLP(gel.β, gel.σ, gel.γ, s, x, ν, z, w, z)\nvgel = varianceBLP(gel.β, gel.σ, gel.γ, s, x, ν, z, w,z,W=inv(v.varm))\n\nf(v) = @sprintf(\"(%.2f)\", sqrt(v))\nvtbl = permutedims(hcat(tbl[1,:],\n                        [hcat(tbl[i+1,:],\n                              [\"\", \"\", f.([vnfxp.Σ[i,i], vmpec.Σ[i,i], vgel.Σ[i,i]])...])\n                         for i in 1:size(vgel.Σ,1)]...\n                        ))\npretty_table(vtbl, noheader=true, formatter=ft_printf(\"%6.3f\",3:5))","category":"page"},{"location":"simulation/#","page":"Simulations","title":"Simulations","text":"As you can see, these standard errors are suspiciously large. It is possible that there is an error in the code, but I think the problem lies in the functional form of the unconditional instruments.","category":"page"},{"location":"simulation/#Optimal-Instruments-1","page":"Simulations","title":"Optimal Instruments","text":"","category":"section"},{"location":"simulation/#","page":"Simulations","title":"Simulations","text":"The above estimators use the unconditional moment restriction ","category":"page"},{"location":"simulation/#","page":"Simulations","title":"Simulations","text":"E(xi omega) z =0","category":"page"},{"location":"simulation/#","page":"Simulations","title":"Simulations","text":"If we assume the conditional moment restriction,","category":"page"},{"location":"simulation/#","page":"Simulations","title":"Simulations","text":"E(xi omega)  z =0","category":"page"},{"location":"simulation/#","page":"Simulations","title":"Simulations","text":"then, we can potentially use any function of z to form unconditional moments. ","category":"page"},{"location":"simulation/#","page":"Simulations","title":"Simulations","text":"E(xi omega) f(z) =0","category":"page"},{"location":"simulation/#","page":"Simulations","title":"Simulations","text":"The optimal (minimal asymptotic variance) choice of f(z) is ","category":"page"},{"location":"simulation/#","page":"Simulations","title":"Simulations","text":"fracpartialpartial theta E(xi omega)  z =0","category":"page"},{"location":"simulation/#","page":"Simulations","title":"Simulations","text":"optimalIV approximates the optimal instruments by taking as initial estimate of theta, computing fracpartial (xi omega)partial theta for each observation in the data, and then regressing this on a polynomial function of z. Using the fitted values from this regression as f(z) results in much more precise estimates of theta. ","category":"page"},{"location":"simulation/#","page":"Simulations","title":"Simulations","text":"zd,zs=optimalIV(gel.β, max.(gel.σ, 0.1), # calculating optimal IV with σ near 0 gives poor peformance\n                gel.γ, s, x, ν, z, w);","category":"page"},{"location":"simulation/#","page":"Simulations","title":"Simulations","text":"@time nfxp = estimateBLP(s, x, ν, zd, w, zs, method=:NFXP, verbose=false)\n@time mpec = estimateBLP(s, x, ν, zd, w, zs, method=:MPEC,verbose=false);\n@time gel = estimateBLP(s, x, ν, zd, w, zs, method=:GEL,verbose=false);","category":"page"},{"location":"simulation/#","page":"Simulations","title":"Simulations","text":"vnfxp = varianceBLP(nfxp.β, nfxp.σ, nfxp.γ, s, x, ν, zd, w, zs)\nvmpec = varianceBLP(mpec.β, mpec.σ, mpec.γ, s, x, ν, zd, w, zs)\nv = varianceBLP(gel.β, gel.σ, gel.γ, s, x, ν, zd, w, zs)\nvgel = varianceBLP(gel.β, gel.σ, gel.γ, s, x, ν, zd, w,zs,W=inv(v.varm))\n\nf(v) = @sprintf(\"(%.2f)\", sqrt(v))\ntbl = vcat([\"\" \"True\" \"NFXP\" \"MPEC\" \"GEL\"],\n           [(i->\"β[$i]\").(1:length(β)) β nfxp.β mpec.β gel.β],\n           [(i->\"σ[$i]\").(1:length(σ)) σ nfxp.σ mpec.σ gel.σ],\n           [(i->\"γ[$i]\").(1:length(γ)) γ nfxp.γ mpec.γ gel.γ])\nvtbl = permutedims(hcat(tbl[1,:],\n                        [hcat(tbl[i+1,:],\n                              [\"\", \"\", f.([vnfxp.Σ[i,i], vmpec.Σ[i,i], vgel.Σ[i,i]])...])\n                         for i in 1:size(vgel.Σ,1)]...\n                        ))\npretty_table(vtbl, noheader=true, formatter=ft_printf(\"%6.3f\",3:5))","category":"page"},{"location":"simulation/#","page":"Simulations","title":"Simulations","text":"We see that with the optimal instruments all three methods produce essentially the same results (in this case, theoretically, NFXP=MPEC, and both are asymptotically equivalent to GEL, so this is expected). Moreover, the estimates are now much more precise and quite close to the true parameter values.","category":"page"},{"location":"#BLPDemand.jl-1","page":"Home","title":"BLPDemand.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Estimate random coefficients demand models in the style of Berry, Levinsohn, and Pakes (1995).","category":"page"},{"location":"#","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Model-1","page":"Home","title":"Model","text":"","category":"section"},{"location":"#Demand-1","page":"Home","title":"Demand","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"There are J products available. We have data from T markets on product shares, s[j,t], K product characteristics, x[k,j,t], L instruments, z[l,j,t], and C cost shifters, w[c,j,t].","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Market shares come from a random coefficients model. ","category":"page"},{"location":"#","page":"Home","title":"Home","text":"sjt = int fracexp(xjt(beta + nu*sigma) + xijt)1 + sum_ell exp(xellt(beta + nu * sigma) + xiellt) dF_nu","category":"page"},{"location":"#","page":"Home","title":"Home","text":"where beta and sigma are parameters to be estimates, xi are market level demand shocks, and nu represents heteregeneity in tastes for characteristics. Let ","category":"page"},{"location":"#","page":"Home","title":"Home","text":"deltajt = xjtbeta + xijt","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Then we can write shares as","category":"page"},{"location":"#","page":"Home","title":"Home","text":"sjt = int fracexp(deltajt + xjt(nu * sigma)1 + sum_ell exp(deltaellt + xellt*nu * sigma) dF_nu","category":"page"},{"location":"#","page":"Home","title":"Home","text":"the right hand side of this equation is computed by  share(δ, σ, x,ν). ","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Conversely, given s[:,t] we can solve for δ[:,t] using delta(s, x, ν, σ). ","category":"page"},{"location":"#","page":"Home","title":"Home","text":"To estimate theta=(betasigma), we assume that ","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Exi_jt * z_cdotjt = 0","category":"page"},{"location":"#","page":"Home","title":"Home","text":"and minimize a quadratic form in the corresponding empirical moments, ","category":"page"},{"location":"#","page":"Home","title":"Home","text":"m = [mean(xi.*z[l,:,:]) for l in 1:L]\nm'*W*m","category":"page"},{"location":"#","page":"Home","title":"Home","text":"See demandmoments and estimateRCIVlogit. ","category":"page"},{"location":"#Supply-1","page":"Home","title":"Supply","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"For the supply side of the model, we assume that x[1,:,:] is price. Marginal costs are log linear and firms choose prices in Bertrand-Nash competition, so (for single product firms)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(pjt - exp(wjtgamma + omegajt)) fracpartial\nspartial x1 + sjt = 0","category":"page"},{"location":"#","page":"Home","title":"Home","text":"For estimation, as with demand, we assume that","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Eomega_jt * z_cdotjt = 0","category":"page"},{"location":"#","page":"Home","title":"Home","text":"and minimize a quadratic form in the corresponding empirical moments (along with the demand moments above). ","category":"page"},{"location":"#","page":"Home","title":"Home","text":"See supplymoments and estimateBLP","category":"page"}]
}
