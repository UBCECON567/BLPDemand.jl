var documenterSearchIndex = {"docs":
[{"location":"functions/#Function-Reference","page":"Function Reference","title":"Function Reference","text":"","category":"section"},{"location":"functions/","page":"Function Reference","title":"Function Reference","text":"Modules = [BLPDemand]","category":"page"},{"location":"functions/#BLPDemand.BLPData","page":"Function Reference","title":"BLPDemand.BLPData","text":"Data set for BLP demand model.\n\n\n\n\n\n","category":"type"},{"location":"functions/#BLPDemand.MarketData","page":"Function Reference","title":"BLPDemand.MarketData","text":"Data from a single market for a BLP demand model\n\n\n\n\n\n","category":"type"},{"location":"functions/#BLPDemand.blpdata-Tuple{AbstractMatrix, AbstractArray{T, 3} where T, AbstractArray{T, 3} where T, AbstractArray{T, 3} where T}","page":"Function Reference","title":"BLPDemand.blpdata","text":"Constructs data for IV random coefficients logit model from arrays. Compared to MarketData, each argument should have one more dimension with length T=number of markets\n\n\n\n\n\n","category":"method"},{"location":"functions/#BLPDemand.blpdata-Tuple{AbstractMatrix, Vararg{AbstractArray{T, 3} where T, 5}}","page":"Function Reference","title":"BLPDemand.blpdata","text":"Constructs data for BLP demand model from arrays. Compared to MarketData, each argument should have one more dimension with length T=number of markets\n\n\n\n\n\n","category":"method"},{"location":"functions/#BLPDemand.blpdata-Tuple{DataFrames.DataFrame, Symbol, Symbol, Symbol, Vector{Symbol}, Vector{Symbol}, Vector{Symbol}, Vector{Symbol}, AbstractArray{T, 3} where T}","page":"Function Reference","title":"BLPDemand.blpdata","text":"function blpdata(df::AbstractDataFrame,\n             mid::Symbol,\n             firmid::Symbol,\n             s::Symbol,                 \n             x::Vector{Symbol},\n             w::Vector{Symbol},\n             zd::Vector{Symbol},\n             zs::Vector{Symbol},\n             ν::AbstractArray{T,3} where T)\n\nConstruct BLPData from a DataFrame.\n\nArguments\n\ndf::AbstractDataFrame\nmid::Symbol market identifier in df\ns::Symbol market shares \nx::Vector{Symbol} columns of df of product characteristics. x[1] must be price\nw::Vector{Symbol} cost shifters\nzd::Vector{Symbol} demand instruments\nzs::Vector{Symbol} supply instruments\nν::Array{T, 3} where T K × S × T array of draws for Monte Carlo integration\n\nSee also MarketData\n\n\n\n\n\n","category":"method"},{"location":"functions/#BLPDemand.data_blp1999-Tuple{}","page":"Function Reference","title":"BLPDemand.data_blp1999","text":"function loadblpdata()\n\nLoads data from Berry, Levinsohn, and Pakes (1999).\n\nReturns a DataFrame.\n\n\n\n\n\n","category":"method"},{"location":"functions/#BLPDemand.delta-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractMatrix{T}, AbstractMatrix{T}, AbstractVector{T}}} where T","page":"Function Reference","title":"BLPDemand.delta","text":"function delta(s, x, ν, σ;                 tol=sqrt(eps(eltype(s))), maxiter=1000)\n\nSolves for δ in s = share(δ, ...) using contraction mapping iteration.\n\nSee also: share\n\n\n\n\n\n","category":"method"},{"location":"functions/#BLPDemand.demandmoments-Tuple{AbstractVector, AbstractVector, Vector{MarketData}}","page":"Function Reference","title":"BLPDemand.demandmoments","text":"demandmoments(β::AbstractVector,σ::AbstractVector,\n                       dat::BLPData)\n\nDemand side moments in BLP model.\n\nArguments\n\nβ length K (=number characteristics) vector of average tastes for characteristics\nσ length K vector of standard deviations of tastes\ndat::BLPData\n\nReturns (moments, ξ) where vector of moments is length L with moments[l] = 1/(JT) ∑ⱼ∑ₜ ξ[t][j]*dat[t].zd[l,j]\n\nSee also: share, delta, simulateRCIVlogit\n\n\n\n\n\n","category":"method"},{"location":"functions/#BLPDemand.dsharedp-Tuple{AbstractVector, AbstractVector, AbstractVector, AbstractMatrix, AbstractMatrix, AbstractVector}","page":"Function Reference","title":"BLPDemand.dsharedp","text":"function dsharedp(β::AbstractVector,\n              σ::AbstractVector,\n              p::AbstractVector,\n              x::AbstractMatrix,\n              ν::AbstractMatrix,\n              ξ::AbstractVector)\n\nCompute market shares and their derivatives in BLP random coefficients demand model.\n\nSee sharep for argument details.\n\nReturns\n\ns vector J market shares\nds J × J Jacobian matrix with ds[l,j] = ∂s[l]/∂p[j]\nΛ J × J diagonal matrix with ds = Λ - Γ\nΓ J × J matrix \n\nSee eqprices for usage of Λ and Γ.    \n\n\n\n\n\n","category":"method"},{"location":"functions/#BLPDemand.eqprices-Tuple{AbstractVector, AbstractVector, AbstractVector, AbstractVector, AbstractMatrix, AbstractMatrix}","page":"Function Reference","title":"BLPDemand.eqprices","text":"function eqprices(mc::AbstractVector,\n                  β::AbstractVector, σ::AbstractVector,\n                  ξ::AbstractVector,\n                  x, ν;\n                  firmid= 1:length(mc),\n                  tol=sqrt(eps(eltype(mc))),\n                  maxiter=10000)\n\nCompute equilibrium prices in BLP model using ζ contraction method of Morrow & Skerlos (2011).\n\nArguments\n\nmc vector of J marginal costs\nβ vector of K taste coefficients\nσ vector of K taste standard deviations\nξ vector of J demand shocks\nx (K-1) × J exogenous product characteristics\nν K × S × T array of draws of ν\nfirmid= (1:J) identifier of firm producing each good. Default value assumes each good is produced by a different firm.\ntol convergence tolerance\nmaxiter maximum number of iterations.\n\n\n\n\n\n","category":"method"},{"location":"functions/#BLPDemand.estimateBLP-Tuple{Vector{MarketData}}","page":"Function Reference","title":"BLPDemand.estimateBLP","text":"estimateBLP(dat::BLPData; method=:MPEC, verbose=true, W=I, optimizer=optimizer_with_attributes(Ipopt.Optimizer, start_with_resto=>\"no\"), supply=true)\n\nEstimates a random coefficients BLP demand model\n\nArguments\n\ndat::BLPData\nmethod=:MPEC method for estimation. Available choices are :MPEC, :NFXP, or :GEL.\nverbose=true whether to display information about optimization progress\nW=I L × L weighting matrix for moments.\nmax_iter=200 number of iterations of optimizer\noptimizer=(method==:NFXP ? LBFGS(linesearch=LineSearches.HagerZhang()) :                             optimizer_with_attributes(Ipopt.Optimizer,                                            \"max_iter\"=> 100,                                            \"start_with_resto\" => \"no\",                                            \"print_level\" => 5*verbose))  optimization method. See below for details.\nsupply=true whether to include supply side moments\nβ0=nothing initial value for β. If isnothing, then will set automatically.\nσ0=nothing initial value for σ. If isnothing, then will set automatically.\nγ0=nothing initial value of γ. If isnothing, then will set automatically.\n\nDetails\n\nUses L unconditional moments for estimation. The moments are moments[l] = 1/(T) ∑ₜ∑ⱼ (ξ[t][t]*dat[t].zd[l,j] + ω[t][j]*dat[t].zs[l,j])\n\nMethods\n\n:NFXP nested fixed point GMM. minimize_θ G(δ(θ),θ)'W G(δ(θ),θ)\n:MPEC constrainted GMM. minimize_{θ,Δ} G(Δ, θ)' W G(Δ, θ) s.t. Δ = δ(θ)\n:GEL constrained empiricla likelihood  maximize_{p, θ, Δ} ∑ₜ log(p[t]) s.t. E_p[g(Δ, θ)] = 0 and Δ = δ(θ)  For some models, there might be no feasible point for EL. This is  especially likely if the number of moments is large.\n\nsupply=false should give the same results as estimateRCIVlogit. However, with method=:MPEC or :GEL, the formulation of the JuMP model differs, and so might the results. Generally, estimateRCIVlogit is faster for data with a small number of products, but scales very poorly as the number of products increases. See the developer notes for more information.\n\nOptimizers\n\nIf method=:NFXP, optimizer should be an unconstrained optimizer from the Optim.jl package. The default of LBFGS() is usually a good choice. BFGS() instead of LBFGS() and/or changing linesearch to LineSearches.BackTracking() are also worth trying.\n\nIf method=:MPEC or :GEL, the optimizer must be comptible with JuMP and capable of solving nonliner problems. The default, Ipopt, will occassionally fail. If verbose is true and you repeatedly see warning messages from Ipopt, then it is likely that Ipopt will run for many iterations and eventually fail to converge. Changing Ipopt's start_with_reso option sometimes helps. For problems of the size seen in the docs or tests, when Ipopt succeeds, it generally does so in 100 or fewer iterations. Ipopt has many additional options, see the Ipopt documentation for a complete list.\n\nSee also: optimalIV, varianceBLP, simulateBLP\n\n\n\n\n\n","category":"method"},{"location":"functions/#BLPDemand.estimateRCIVlogit-Tuple{Vector{MarketData}}","page":"Function Reference","title":"BLPDemand.estimateRCIVlogit","text":"estimateRCIVlogit(dat::BLPData; method=:MPEC, verbose=true, W=I)\n\nEstimates a random coefficients IV logit model.\n\nArguments\n\ndat::BLPData\nmethod=:MPEC method for estimation. Available choices are :MPEC, :NFXP, or :GEL\nverbose=true whether to display information about optimization progress\nW=I weighting matrix\nmax_iter optimizer iteration limit\noptimizer see estimateBLP for details\nβ0=nothing initial value for β. If isnothing, then will try to automatically set\nσ0=nothing initial value for σ. If isnothing, then will try to automatically set\n\nNote that methods :MPEC and :GEL use a large amount of memory when the number of products is large. Either method=:NFXP or estimateBLP with supply=false should be used if the number of products is large.\n\n\n\n\n\n","category":"method"},{"location":"functions/#BLPDemand.fracRCIVlogit-Tuple{Vector{MarketData}}","page":"Function Reference","title":"BLPDemand.fracRCIVlogit","text":"fracRCIVlogit(dat::BLPData)\n\nEstimate random coefficients IV model using \"Fast, Robust, Approximately Correct\" method of Salanie & Wolak (2019)\n\n\n\n\n\n","category":"method"},{"location":"functions/#BLPDemand.makeivblp-Tuple{AbstractMatrix}","page":"Function Reference","title":"BLPDemand.makeivblp","text":"makeivblp(x::AbstractMatrix, firmid=1:size(x,2))\n\nFunction for constructing demand instrumental variables following BLP (1995).\n\nInstruments consist of exogenous product characteristics, sum of rivals exogenous characteristics, and, if there are any multi-product firms, sum of characteristics of other goods produced by the same firm.\n\nIf includeexp is true, then also use sum(exp(-([x[2:end,j,t] - x[l,j,t])^2) for l in 1:J)) as instruments.\n\n\n\n\n\n","category":"method"},{"location":"functions/#BLPDemand.makeivblp-Tuple{Vector{MarketData}}","page":"Function Reference","title":"BLPDemand.makeivblp","text":"makeivblp(dat::BLPData; includeexp=true)\n\nSets dat[:].zd and dat[:].zs to makeivblp([x[2:end,:] w])\n\n\n\n\n\n","category":"method"},{"location":"functions/#BLPDemand.optimalIV-Tuple{Any, Any, Any, Vector{MarketData}}","page":"Function Reference","title":"BLPDemand.optimalIV","text":"optimalIV(β, σ, γ, dat::BLPData ; degree=2)\n\nComputes optimal instruments for BLP model. Given initial estimates θ=(β, σ, γ), computes e(θ)ⱼₜ = (ξ(θ)ⱼₜ , ω(θ)ⱼₜ), and then approximates the optimal instruments with a polynomial regression of degree of ∂e/∂θ on z. Returns BLPData with instruments set to fitted values (zd, zs) = (E[∂ξ/∂θ|z], E[∂ω/∂θ|z])\n\nNotes\n\nThis function has not be carefully tested and should be considered experimental.\nThis code assumes homoskedasticity to construct the optimal iv, E[ee'|z] = E[ee']\n\n\n\n\n\n","category":"method"},{"location":"functions/#BLPDemand.polyreg-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix}","page":"Function Reference","title":"BLPDemand.polyreg","text":"  polyreg(xpred::AbstractMatrix,\n          xdata::AbstractMatrix,\n          ydata::AbstractMatrix; degree=1)\n\nComputes  polynomial regression of ydata on xdata. Returns predicted y at x=xpred.\n\nArguments\n\nxpred x values to compute fitted y\nxdata observed x\nydata observed y, must have size(y)[1] == size(xdata)[1]\ndegree\nderiv whether to also return df(xpred). Only implemented when  xdata is one dimentional\n\nReturns\n\nEstimates of f(xpred)\n\n\n\n\n\n","category":"method"},{"location":"functions/#BLPDemand.share-Tuple{AbstractVector, AbstractVector, AbstractMatrix, AbstractMatrix}","page":"Function Reference","title":"BLPDemand.share","text":"function share(δ::AbstractVector, σ::AbstractVector, x::AbstractMatrix, ν::AbstractMatrix)\n\nCompute market shares in BLP random coefficients demand model.\n\nMarket shares are given by \n\n s_j = int frace^delta_j + x_j σ ν1+sum_i=1^J e^delta_i + x_i σ ν dF_ν(ν)\n\nArguments:\n\nδ vector of length J= number of products\nσ vector of length K= number of characteristics\nx K × J matrix of product characteristics\nν K × S matrix of simulation draws for integration\n\nReturns vector of length J market shares. \n\nSee also: delta\n\n\n\n\n\n","category":"method"},{"location":"functions/#BLPDemand.sharep-Tuple{AbstractVector, AbstractVector, AbstractVector, AbstractMatrix, AbstractMatrix, AbstractVector}","page":"Function Reference","title":"BLPDemand.sharep","text":"function sharep(β::AbstractVector,                    σ::AbstractVector,                    p::AbstractVector,                    x::AbstractMatrix,                    ν::AbstractMatrix,                    ξ::AbstractVector)\n\nCompute market shares in BLP random coefficients demand model.\n\nMarket shares are given by \n\n s_j = int frace^delta_j + x_j σ ν1+sum_i=1^J e^delta_i + x_i σ ν dF_ν(ν)\n\nwhere \n\ndelta_j = β1*pj + xj *β2end + ξj\n\nArguments:\n\nβ vector of length K= number of characteristics\nσ vector of length K= number of characteristics\np J vector of prices\nx (K-1) × J matrix of exogenous product characteristics\nν K × S matrix of simulation draws for integration\nξ J vector of demand shocks\n\nReturns vector of length J market shares. \n\nSee also: share, dsharedp  \n\n\n\n\n\n","category":"method"},{"location":"functions/#BLPDemand.simulateBLP-Tuple{Any, Any, AbstractVector, AbstractVector, AbstractVector, Any}","page":"Function Reference","title":"BLPDemand.simulateBLP","text":"function simulateBLP(J, T, β, σ, γ, S; varξ=1, varω=1, randj=1.0, firmid=1:J, costf=:log)\n\nSimulates a BLP demand and supply model.\n\nArguments\n\nJ numebr of products\nT::Integer number of markets\nβ::AbstractVector with length(β)=K, average tastes for characteristics. The first characteristic will be endogeneous (price)\nσ::AbstractVector with length(σ)=K, standard deviation of tastes for characteristics\nγ::AbstractVector marginal cost coefficients\nS number of simulation draws to calculate market shares\nvarξ=1 variance of ξ\nvarω=1 variance of ω\nrandj=1.0 if less than 1, then J is the maximum number of products per market. Each product is included in each market with probability randj\nfirmid=1:J firm identifiers. Must be length J.\n\nReturns\n\ndat a BLPData struct\nξ\nω\n\n\n\n\n\n","category":"method"},{"location":"functions/#BLPDemand.simulateIVRClogit-NTuple{6, Any}","page":"Function Reference","title":"BLPDemand.simulateIVRClogit","text":"function simulateIVRClogit(T, β, σ, π, ρ, S)\n\nSimulates a random coefficients logit model with endogeneity.\n\nArguments\n\nT::Integer number of markets\nβ::AbstractVector with length(β)=K, average tastes for characteristics.\nσ::AbstractVector with length(σ)=K, standard deviation of tastes for characteristics\nπ::AbstractMatrix with size(π) = (L, K, J), first stage coefficients\nρ::Number strength of endogeneity\nS number of simulation draws to calculate market shares\n\nReturns BLPData struct\n\n\n\n\n\n","category":"method"},{"location":"functions/#BLPDemand.supplymoments-Tuple{AbstractVector, AbstractVector, AbstractVector, AbstractVector, Vector{MarketData}}","page":"Function Reference","title":"BLPDemand.supplymoments","text":"supplymoments(γ::AbstractVector, β::AbstractVector, σ::AbstractVector,\n                   ξ::AbstractVector, dat::BLPData)\n\nSupply side moments in a BLP model. Assumes that marginal cost is costf linear,\n\ncostf(c_jt) = w_jtγ + ω_jt\n\nand prices are Bertrand-Nash\n\nc_t = p_t + (sp)^-1 s\n\nwhere ∂s/∂p is the Jacobian of shares with respect to prices, but with the j,l entry set to zero unless goods j and l are produced by the same firm.\n\nArguments\n\nγ marginal cost coefficients\nβ length K (=number characteristics) vector of average tastes for characteristics\nσ length K vector of standard deviations of tastes\nξ J × T matrix of market demand shocks\ndat::BLPData\n\nReturns (moments, ω) an L vector of moments with moments[l] = 1/(T) ∑ₜ∑ⱼ ω[t][j]*dat[t].zs[l,j]\n\nNotes:\n\nMay encounter numeric problems if costf has a limited domain. In particular, for some values of parameters, we may have\n\np_t + (sp)^-1 s  0\n\nin which case the implied marginal cost is negative.\n\n\n\n\n\n","category":"method"},{"location":"functions/#BLPDemand.tran-Tuple{Any}","page":"Function Reference","title":"BLPDemand.tran","text":"pack(β::AbstractVector, σ::AbstractVector, ...)\n\nPacks parameters into a single vector, θ.\n\nReturns tuple with the packed parameters, θ, and a function to unpack them, i.e.\n\nunpack(θ) = (β, σ, ...)\n\nand\n\npack(unpack(θ)) = θ\n\n\n\n\n\n","category":"method"},{"location":"functions/#BLPDemand.varianceBLP-Tuple{Any, Any, Any, Vector{MarketData}}","page":"Function Reference","title":"BLPDemand.varianceBLP","text":"varianceBLP(β, σ, γ, dat::BLPData ; W=I)\n\nComputes variance of BLP estimates. Computes moment variance clustering on t.\n\nReturns Σ = covariance of [β, σ, γ] and varm = (clustered) covariance of moments.\n\n\n\n\n\n","category":"method"},{"location":"functions/#BLPDemand.varianceRCIVlogit-Tuple{Any, Any, Vector{MarketData}}","page":"Function Reference","title":"BLPDemand.varianceRCIVlogit","text":"varianceRCIVlogit(β, σ, dat::BLPData ; W=I)\n\nComputes variance of RCIVlogit estimates. Computes moment variance clustering on t.\n\nReturns Σ = covariance of [β, σ, γ] and varm = (clustered) covariance of moments.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Index","page":"Function Reference","title":"Index","text":"","category":"section"},{"location":"functions/","page":"Function Reference","title":"Function Reference","text":"","category":"page"},{"location":"replicateblp/","page":"Replicating BLP","title":"Replicating BLP","text":"(Image: )","category":"page"},{"location":"replicateblp/","page":"Replicating BLP","title":"Replicating BLP","text":"This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License","category":"page"},{"location":"replicateblp/#About-this-document","page":"Replicating BLP","title":"About this document","text":"","category":"section"},{"location":"replicateblp/","page":"Replicating BLP","title":"Replicating BLP","text":"This document was created using Weave.jl. The code is available in on github. The same document generates both static webpages and a jupyter notebook.","category":"page"},{"location":"replicateblp/#Introduction","page":"Replicating BLP","title":"Introduction","text":"","category":"section"},{"location":"replicateblp/","page":"Replicating BLP","title":"Replicating BLP","text":"This assigment will attempt to replicate the results of [@berry1995].","category":"page"},{"location":"replicateblp/#Getting-started","page":"Replicating BLP","title":"Getting started","text":"","category":"section"},{"location":"replicateblp/","page":"Replicating BLP","title":"Replicating BLP","text":"Load the package for this assignment from github.","category":"page"},{"location":"replicateblp/","page":"Replicating BLP","title":"Replicating BLP","text":"using Pkg\n#Pkg.activate(\".\") # If running on  vse.syzygy.ca, you might need to uncomment this command\ntry\n  using BLPDemand\ncatch\n  Pkg.develop(PackageSpec(url=\"https://github.com/UBCECON567/BLPDemand.jl\"))\n  using BLPDemand\nend","category":"page"},{"location":"replicateblp/#Problem-1:-load-and-explore-the-data","page":"Replicating BLP","title":"Problem 1: load and explore the data","text":"","category":"section"},{"location":"replicateblp/","page":"Replicating BLP","title":"Replicating BLP","text":"The data from [@berry1995] is included in the BLPDemand.jl package.","category":"page"},{"location":"replicateblp/","page":"Replicating BLP","title":"Replicating BLP","text":"df = data_blp1999()\n\n# Optionally, if you like being able to view all your data\nif (false)\n  using TableView\n  if (notusingjupyterorjuno) # this will throw an error. Delete it  or the else branch \n    using Blink\n    w = Blink.window()\n    body!(w, TableView.showtable(df));\n  else  # this may work on a local installation of jupyter, but it doesn't on vse.syzygy.ca ...\n    TableView.showtable(df);\n  end\nend","category":"page"},{"location":"replicateblp/","page":"Replicating BLP","title":"Replicating BLP","text":"Error: ArgumentError: provide a valid sink argument, like `using DataFrames\n; CSV.read(source, DataFrame)`","category":"page"},{"location":"replicateblp/","page":"Replicating BLP","title":"Replicating BLP","text":"Create some tables and figures to explore the data. You may want to reproduce table I and/or II from [@berry1995].","category":"page"},{"location":"replicateblp/","page":"Replicating BLP","title":"Replicating BLP","text":"# using Plots, DataFramesMeta, StatsPlots # (or whatever)","category":"page"},{"location":"replicateblp/#Problem-2:-Logit-Demand","page":"Replicating BLP","title":"Problem 2: Logit Demand","text":"","category":"section"},{"location":"replicateblp/#Part-I","page":"Replicating BLP","title":"Part I","text":"","category":"section"},{"location":"replicateblp/","page":"Replicating BLP","title":"Replicating BLP","text":"Reproduce table III of [@berry1995]. First you’ll need to create instruments as in section 5.1 of the paper. The following code should do it.","category":"page"},{"location":"replicateblp/","page":"Replicating BLP","title":"Replicating BLP","text":"using DataFrames\n# Create instruments (see section 5.1)\nexog = [:const, :hpwt, :air, :mpd, :space, :mpg, :trend] # not sure that this is correct set of variables\nfunction makeinstruments(df, exog)\n  for z ∈ exog\n    zown = String(z).*\"_own\"\n    zother = String(z).*\"_other\"\n    own=by(df, [:year, :firm_id], z=>sum)\n    rename!(own, Symbol(z, \"_sum\") => Symbol(z, \"_own\"))\n    all=by(df, [:year], z=>sum)\n    rename!(all, Symbol(z, \"_sum\") => Symbol(z, \"_other\"))\n    df=join(df, own, on = [:year, :firm_id])\n    df=join(df,all, on = [:year])\n    df[!,Symbol(z,\"_other\")] .-= df[!,Symbol(z,\"_own\")]\n    df[!,Symbol(z,\"_own\")] .-= df[!,z]\n  end\n  return(df)\nend\ndf=makeinstruments(df, exog);\nnothing","category":"page"},{"location":"replicateblp/","page":"Replicating BLP","title":"Replicating BLP","text":"Error: UndefVarError: df not defined","category":"page"},{"location":"replicateblp/","page":"Replicating BLP","title":"Replicating BLP","text":"For the regressions, you should modify the following.","category":"page"},{"location":"replicateblp/","page":"Replicating BLP","title":"Replicating BLP","text":"using FixedEffectModels, RegressionTables\ncol2 = reg(df, @formula(logit_depvar ~ hpwt + (price ~ const_own + const_other + hpwt_own + hpwt_other)))\nregtable(col2)","category":"page"},{"location":"replicateblp/","page":"Replicating BLP","title":"Replicating BLP","text":"Error: UndefVarError: df not defined","category":"page"},{"location":"replicateblp/#Part-II","page":"Replicating BLP","title":"Part II","text":"","category":"section"},{"location":"replicateblp/","page":"Replicating BLP","title":"Replicating BLP","text":"Calculate the elasticities of demand implied by the logit model. Report how many own price elasticities have absolute value less than one (inelastic). Why are inelastic demand estimates undesirable?","category":"page"},{"location":"replicateblp/","page":"Replicating BLP","title":"Replicating BLP","text":"For computing the elastiticities, you could adapt the code from the BLPDemand.jl docs","category":"page"},{"location":"replicateblp/","page":"Replicating BLP","title":"Replicating BLP","text":"","category":"page"},{"location":"replicateblp/#Problem-3:-Demand-Side-Estimation","page":"Replicating BLP","title":"Problem 3: Demand Side Estimation","text":"","category":"section"},{"location":"replicateblp/","page":"Replicating BLP","title":"Replicating BLP","text":"Estimate a random coefficients demand model. Report the parameter estimates and standard errors. Use the functions estimateRCIVlogit and varianceRCIVlogit from BLPDemand.jl. Note that the paper has price enter the model as log(y-p), but we lack data on y, so just have price enter linearly or log-linearly with a random coefficient.","category":"page"},{"location":"replicateblp/","page":"Replicating BLP","title":"Replicating BLP","text":"# some more data prep. You might want to change\ndf[!,:loghpwt] = log.(df[!,:hpwt])\ndf[!,:logmpg] = log.(df[!,:mpg])\ndf[!,:logspace] = log.(df[!,:space])\nS = 20\nxvars = [:price, :const, :hpwt, :air, :mpd, :space]\ncostvars = [:const, :loghpwt, :air, :logmpg, :logspace]\ndat = BLPData(df, :year, :firm_id, :share, xvars, costvars,\n              [:const], [:const], # we'll recreate instruments anyway\n              randn(length(xvars),S ,length(unique(df[!,:year]))) )\ndat = makeivblp(dat, includeexp=false)\n\nusing LinearAlgebra: diag, I\n# now the estimation, you might want to try different options\n\n#out=estimateRCIVlogit(dat, method=:NFXP, verbose=true, W=I)\n#v = varianceRCIVlogit(out.β, out.σ, dat, W=I)\n#@show [out.β  out.σ]\n#@show sqrt.(diag(v.Σ))\n\n# or make a nicer table as in https://ubcecon567.github.io/BLPDemand.jl/dev/simulation/#Estimation-1","category":"page"},{"location":"replicateblp/","page":"Replicating BLP","title":"Replicating BLP","text":"Error: UndefVarError: df not defined","category":"page"},{"location":"replicateblp/#Problem-4:-Demand-and-Supply","page":"Replicating BLP","title":"Problem 4: Demand and Supply","text":"","category":"section"},{"location":"replicateblp/","page":"Replicating BLP","title":"Replicating BLP","text":"Estimate the full BLP model. Use the estimateBLP and varianceBLP functions. See the docs for example usage. Note that the paper has price enter the model as log(y-p), but we lack data on y, so just have price enter linearly or log-linearly with a random coefficient.","category":"page"},{"location":"replicateblp/","page":"Replicating BLP","title":"Replicating BLP","text":"","category":"page"},{"location":"replicateblp/#Problem-5:-Elasticities","page":"Replicating BLP","title":"Problem 5: Elasticities","text":"","category":"section"},{"location":"replicateblp/","page":"Replicating BLP","title":"Replicating BLP","text":"Compute price elasticities (with standard errors) based on your estimates. You can adapt the code in the docs.","category":"page"},{"location":"replicateblp/","page":"Replicating BLP","title":"Replicating BLP","text":"","category":"page"},{"location":"replicateblp/#Problem-6:-Merger-Simulation","page":"Replicating BLP","title":"Problem 6: Merger Simulation","text":"","category":"section"},{"location":"replicateblp/","page":"Replicating BLP","title":"Replicating BLP","text":"This is a more challenging problem with less guidance. Consider it optional.","category":"page"},{"location":"replicateblp/","page":"Replicating BLP","title":"Replicating BLP","text":"Use your estimates to simulate a merger between firm 11 (Saab, I think) and firm 19 (GM, I think). You can do this by modifying the simulateBLP function. Report the effect of the merger on prices. Be sure to include standard errors.","category":"page"},{"location":"simulation/#Simulations","page":"Simulations","title":"Simulations","text":"","category":"section"},{"location":"simulation/","page":"Simulations","title":"Simulations","text":"Here we perform some monte-carlo simulations to illustrute package usage and estimator performance. See Model for an overview of the model. The tests directory contains some additional examples.","category":"page"},{"location":"simulation/#Generate-Data","page":"Simulations","title":"Generate Data","text":"","category":"section"},{"location":"simulation/","page":"Simulations","title":"Simulations","text":"using BLPDemand, Statistics, PrettyTables, Printf, Random, LinearAlgebra\nK = 2             # number of characteristics\nJ = 6             # number of products\nS = 10            # draws of nu\nT = 100           # number of markets\nβ = ones(K)*2 \nβ[1] = -1.5       # important for equilibrium that higher prices lower sales\nσ = ones(K)\nσ[1] = 0.2\nγ = ones(1)*0.1\nRandom.seed!(98426)\n\n(sim, ξ, ω) = simulateBLP(J,T, β, σ, γ, S, varξ=0.2, varω=0.2);\n@show quantile(vcat((d->d.s[:]).(sim)...), [0, 0.05, 0.5, 0.95, 1])","category":"page"},{"location":"simulation/","page":"Simulations","title":"Simulations","text":"Estimation will encounter numerical difficulties if market shares are very close (within 1e-4) to 0 or 1. The above range should be fine. ","category":"page"},{"location":"simulation/#Instruments","page":"Simulations","title":"Instruments","text":"","category":"section"},{"location":"simulation/","page":"Simulations","title":"Simulations","text":"In the simulated data sim[].x[2:end,:] and sim[].w are uncorrelated with ξ and ω, but price, sim[].x[1,:], is endogenous. The price of the jth firm will depend on the characteristics and costs of all other goods, so these are available as instruments. makeivblp is a convenience function that constructs the sum of all other firms' exogenous variables to use as instruments. This is similar to what Berry, Levinsohn, and Pakes (1995) do. We will see below though that much more accurate estimates can be obtained by using the optimal instruments. makeivblp is used by simulateBLP to generate sim[].zd and sim[].zs.","category":"page"},{"location":"simulation/#Estimation","page":"Simulations","title":"Estimation","text":"","category":"section"},{"location":"simulation/","page":"Simulations","title":"Simulations","text":"We can now estimate the model. Three methods are available: GMM with nested-fixed point (:NFXP), constrained GMM (:MPEC), and constrained GEL (:GEL). See estimateBLP. ","category":"page"},{"location":"simulation/","page":"Simulations","title":"Simulations","text":"@time nfxp = estimateBLP(sim, method=:NFXP, verbose=false)\n@time mpec = estimateBLP(sim, method=:MPEC,verbose=true);\n@time gel = estimateBLP(sim, method=:GEL,verbose=true);","category":"page"},{"location":"simulation/","page":"Simulations","title":"Simulations","text":"tbl = vcat([\"\" \"True\" \"NFXP\" \"MPEC\" \"GEL\"],\n           [(i->\"β[$i]\").(1:length(β)) β nfxp.β mpec.β gel.β],\n           [(i->\"σ[$i]\").(1:length(σ)) σ nfxp.σ mpec.σ gel.σ],\n           [(i->\"γ[$i]\").(1:length(γ)) γ nfxp.γ mpec.γ gel.γ])\npretty_table(tbl, noheader=true, formatter=ft_printf(\"%6.3f\",3:5))","category":"page"},{"location":"simulation/","page":"Simulations","title":"Simulations","text":"In the absence of optimization error and other numeric problems, :NFXP and :MPEC should produce identical results.  In finite sample, we should expect the GEL estimates to differ. All three methods are consistent, but GEL is also asymptotically efficient (for a fixed choice of z; different z can have large effects on efficiency).","category":"page"},{"location":"simulation/#Inference","page":"Simulations","title":"Inference","text":"","category":"section"},{"location":"simulation/","page":"Simulations","title":"Simulations","text":"varianceBLP computes the variance of the estimates produced by either of GMM estimation methods.[simdraws]","category":"page"},{"location":"simulation/","page":"Simulations","title":"Simulations","text":"[^simdraws:] The variance calculation ignores uncertainty from Monte-Carlo integration. For this to be valid, we must have the number of simulation draws grow faster than the sample size. In our notation, S is the number of simulation draws per observation, so it is sufficient at that S to infty as T to infty.","category":"page"},{"location":"simulation/","page":"Simulations","title":"Simulations","text":"vnfxp = varianceBLP(nfxp.β, nfxp.σ, nfxp.γ, sim);\nvmpec = varianceBLP(mpec.β, mpec.σ, mpec.γ, sim);\nnothing","category":"page"},{"location":"simulation/","page":"Simulations","title":"Simulations","text":"Inference for GEL has not been directly implemented. However, GEL is first order asymptotically equivalent to efficiently weigthed GMM. In other words, GEL estimates have the same asymptotic variance as efficiently weighted GMM. ","category":"page"},{"location":"simulation/","page":"Simulations","title":"Simulations","text":"v = varianceBLP(gel.β, gel.σ, gel.γ, sim)\nvgel = varianceBLP(gel.β, gel.σ, gel.γ, sim, W=inv(v.varm))\n\nf(v) = @sprintf(\"(%.2f)\", norm(sqrt(Complex(v))))\nvtbl = permutedims(hcat(tbl[1,:],\n                        [hcat(tbl[i+1,:],\n                              [\"\", \"\", f.([vnfxp.Σ[i,i], vmpec.Σ[i,i], vgel.Σ[i,i]])...])\n                         for i in 1:size(vgel.Σ,1)]...\n                        ))\npretty_table(vtbl, noheader=true, formatter=ft_printf(\"%6.3f\",3:5))","category":"page"},{"location":"simulation/","page":"Simulations","title":"Simulations","text":"These reusults look pretty good. In additional experiments (not shown)  the results were somewhat sensitive to the simulation design and choice of instruments (see makeivblp).","category":"page"},{"location":"simulation/#Optimal-Instruments","page":"Simulations","title":"Optimal Instruments","text":"","category":"section"},{"location":"simulation/","page":"Simulations","title":"Simulations","text":"The above estimators use the unconditional moment restriction ","category":"page"},{"location":"simulation/","page":"Simulations","title":"Simulations","text":"E(xi omega) z =0","category":"page"},{"location":"simulation/","page":"Simulations","title":"Simulations","text":"If we assume the conditional moment restriction,","category":"page"},{"location":"simulation/","page":"Simulations","title":"Simulations","text":"E(xi omega)  z =0","category":"page"},{"location":"simulation/","page":"Simulations","title":"Simulations","text":"then, we can potentially use any function of z to form unconditional moments. ","category":"page"},{"location":"simulation/","page":"Simulations","title":"Simulations","text":"E(xi omega) f(z) =0","category":"page"},{"location":"simulation/","page":"Simulations","title":"Simulations","text":"The optimal (minimal asymptotic variance) choice of f(z) is ","category":"page"},{"location":"simulation/","page":"Simulations","title":"Simulations","text":"fracpartialpartial theta E(xi omega)  z =0","category":"page"},{"location":"simulation/","page":"Simulations","title":"Simulations","text":"optimalIV approximates the optimal instruments by taking as initial estimate of theta, computing fracpartial (xi omega)partial theta for each observation in the data, and then regressing this on a polynomial function of z. Using the fitted values from this regression as f(z) results in much more precise estimates of theta.[z]","category":"page"},{"location":"simulation/","page":"Simulations","title":"Simulations","text":"[z]: The choice of z still matters when using optimalIV. For firm j, the values of x[2:end,l,t] (for both l=j and l != j) are all potential instruments for x[1,j,t]. However, makeivblp does not use all of these. It instead uses their sum and the sum of exp(-(x[2:end,j,t] - x[2:end,l,t])^2). Adjusting these choices might give better results.","category":"page"},{"location":"simulation/","page":"Simulations","title":"Simulations","text":"sim=optimalIV(mpec.β, max.(mpec.σ, 0.1), # calculating optimal IV with σ near 0 gives poor peformance\n              mpec.γ, sim, degree=3);\nnothing","category":"page"},{"location":"simulation/","page":"Simulations","title":"Simulations","text":"@time nfxp = estimateBLP(sim, method=:NFXP, verbose=false)\n@time mpec = estimateBLP(sim, method=:MPEC,verbose=false);\n@time gel = estimateBLP(sim, method=:GEL,verbose=false);","category":"page"},{"location":"simulation/","page":"Simulations","title":"Simulations","text":"vnfxp = varianceBLP(nfxp.β, nfxp.σ, nfxp.γ, sim)\nvmpec = varianceBLP(mpec.β, mpec.σ, mpec.γ, sim)\nv = varianceBLP(gel.β, gel.σ, gel.γ, sim)\nvgel = varianceBLP(gel.β, gel.σ, gel.γ, sim, W=inv(v.varm))\n\nf(v) = @sprintf(\"(%.2f)\", norm(sqrt(Complex(v))))\ntbl = vcat([\"\" \"True\" \"NFXP\" \"MPEC\" \"GEL\"],\n           [(i->\"β[$i]\").(1:length(β)) β nfxp.β mpec.β gel.β],\n           [(i->\"σ[$i]\").(1:length(σ)) σ nfxp.σ mpec.σ gel.σ],\n           [(i->\"γ[$i]\").(1:length(γ)) γ nfxp.γ mpec.γ gel.γ])\nvtbl = permutedims(hcat(tbl[1,:],\n                        [hcat(tbl[i+1,:],\n                              [\"\", \"\", f.([vnfxp.Σ[i,i], vmpec.Σ[i,i], vgel.Σ[i,i]])...])\n                         for i in 1:size(vgel.Σ,1)]...\n                        ))\npretty_table(vtbl, noheader=true, formatter=ft_printf(\"%6.3f\",3:5))","category":"page"},{"location":"simulation/","page":"Simulations","title":"Simulations","text":"We see that with the optimal instruments all three methods produce essentially the same results (in this case, theoretically, NFXP=MPEC, and both are asymptotically equivalent to GEL, so this is expected). Moreover, the estimates are now much more precise and quite close to the true parameter values.","category":"page"},{"location":"simulation/#Calculating-Elasticities","page":"Simulations","title":"Calculating Elasticities","text":"","category":"section"},{"location":"simulation/","page":"Simulations","title":"Simulations","text":"Using share and the ForwardDiff.jl package, we can calculate elasticities of demand with respect to each characteristic.","category":"page"},{"location":"simulation/","page":"Simulations","title":"Simulations","text":"using ForwardDiff\n\nfunction elasticity(β, σ, γ, dat, ξ)\n  T = length(dat)\n  K,J = size(dat[1].x)\n  etype = typeof(dat[1].x[:,1]'*β+ξ[1][1])\n  e = Array{Array{etype,3},1}(undef, T)\n  for t in 1:T\n    @views xt = dat[t].x\n    st(x) = share(x'*β + ξ[t], σ, x, dat[t].ν)\n    ∂s = reshape(ForwardDiff.jacobian(st, xt), J, K, J)\n    s = st(xt)\n    e[t] = zeros(etype, J,K,J)\n    for k in 1:K\n      for j in 1:J\n        e[t][:,k,j] .= ∂s[:,k,j]./s .* xt[k,j]\n      end\n    end\n  end\n  return e\nend\n\nfunction avg_price_elasticity(β,σ,γ, dat)\n  ξ = Vector{Vector{eltype(β)}}(undef, T)\n  for t in 1:T\n    ξ[t] = delta(dat[t].s, dat[t].x, dat[t].ν, σ) - dat[t].x'*β\n  end\n  e=elasticity(β,σ,γ,dat,ξ)\n  avge = zeros(eltype(e[1]),size(e[1]))\n  # this assumes J is the same for all markets\n  for t in 1:T\n    avge .+= e[t]\n  end\n  avge /= T\n  avge[:,1,:]\nend\n\nprice_elasticity = avg_price_elasticity(mpec.β, mpec.σ, mpec.γ, sim)","category":"page"},{"location":"simulation/","page":"Simulations","title":"Simulations","text":"Standard errors of elasticities and other quantities calculated from estimates can be calculated using the delta method.","category":"page"},{"location":"simulation/","page":"Simulations","title":"Simulations","text":"D = ForwardDiff.jacobian(θ->avg_price_elasticity(θ[1:K], θ[(K+1):(2K)], θ[(2K+1):end], sim), [mpec.β;mpec.σ;mpec.γ])\nV = D*vmpec.Σ*D'\nse = reshape(sqrt.(diag(V)), size(price_elasticity))\n\ntbl = Array{Any, 2}(undef, 2J+1, J+1)\ntbl[1,1]=\"\"\nfor j in 1:J\n  tbl[1,j+1] = \"price $j\"\n  tbl[2j,1] = \"share $j\"\n  tbl[2j+1,1] = \"\"\n  for l in 1:J\n    tbl[2j, l+1] = price_elasticity[j,l]\n    tbl[2j+1, l+1] = @sprintf(\"(%.3f)\",se[j,l])\n  end\nend\npretty_table(tbl, noheader=true, formatter=ft_printf(\"%6.3f\", 2:(J+1)))       ","category":"page"},{"location":"simulation/","page":"Simulations","title":"Simulations","text":"The table above shows the estimated average elasticity of each good's share with respect to each good's price. Standard errors are in parentheses.","category":"page"},{"location":"#BLPDemand.jl","page":"Home","title":"BLPDemand.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Estimate random coefficients demand models in the style of Berry, Levinsohn, and Pakes (1995).","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Model","page":"Home","title":"Model","text":"","category":"section"},{"location":"#Demand","page":"Home","title":"Demand","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"There are J products available. We have data from T markets on product shares, s[j,t], K product characteristics, x[k,j,t], L instruments, z[l,j,t], and C cost shifters, w[c,j,t].","category":"page"},{"location":"","page":"Home","title":"Home","text":"Market shares come from a random coefficients model. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"sjt = int fracexp(xjt(beta + nu*sigma) + xijt)1 + sum_ell exp(xellt(beta + nu * sigma) + xiellt) dF_nu","category":"page"},{"location":"","page":"Home","title":"Home","text":"where beta and sigma are parameters to be estimates, xi are market level demand shocks, and nu represents heteregeneity in tastes for characteristics. Let ","category":"page"},{"location":"","page":"Home","title":"Home","text":"deltajt = xjtbeta + xijt","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then we can write shares as","category":"page"},{"location":"","page":"Home","title":"Home","text":"sjt = int fracexp(deltajt + xjt(nu * sigma)1 + sum_ell exp(deltaellt + xellt*nu * sigma) dF_nu","category":"page"},{"location":"","page":"Home","title":"Home","text":"the right hand side of this equation is computed by  share(δ, σ, x,ν). ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Conversely, given s[:,t] we can solve for δ[:,t] using delta(s, x, ν, σ). ","category":"page"},{"location":"","page":"Home","title":"Home","text":"To estimate theta=(betasigma), we assume that ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Exi_jt * z_cdotjt = 0","category":"page"},{"location":"","page":"Home","title":"Home","text":"and minimize a quadratic form in the corresponding empirical moments, ","category":"page"},{"location":"","page":"Home","title":"Home","text":"m = [mean(xi.*z[l,:,:]) for l in 1:L]\nm'*W*m","category":"page"},{"location":"","page":"Home","title":"Home","text":"See demandmoments and estimateRCIVlogit. ","category":"page"},{"location":"#Supply","page":"Home","title":"Supply","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For the supply side of the model, we assume that x[1,:,:] is price. Marginal costs are log linear and firms choose prices in Bertrand-Nash competition, so (for single product firms)","category":"page"},{"location":"","page":"Home","title":"Home","text":"(pjt - exp(wjtgamma + omegajt)) fracpartial\nspartial x1 + sjt = 0","category":"page"},{"location":"","page":"Home","title":"Home","text":"For estimation, as with demand, we assume that","category":"page"},{"location":"","page":"Home","title":"Home","text":"Eomega_jt * z_cdotjt = 0","category":"page"},{"location":"","page":"Home","title":"Home","text":"and minimize a quadratic form in the corresponding empirical moments (along with the demand moments above). ","category":"page"},{"location":"","page":"Home","title":"Home","text":"See supplymoments and estimateBLP","category":"page"},{"location":"implementation/#Developer-Notes","page":"Developer Notes","title":"Developer Notes","text":"","category":"section"},{"location":"implementation/","page":"Developer Notes","title":"Developer Notes","text":"This section contains explanations for implementation details that might otherwise appear strange. ","category":"page"},{"location":"implementation/#Limiting-Memory-Usage-in-JuMP","page":"Developer Notes","title":"Limiting Memory Usage in JuMP","text":"","category":"section"},{"location":"implementation/","page":"Developer Notes","title":"Developer Notes","text":"MPEC and GEL estimation modes use the JuMP package with the Ipopt solver. The JuMP model definitions in estimateBLP introduce many auxillary intermediate variables and constraints. JuMP is able to automatic generate efficient code to evaluate linear and quadratic expressions (and their derivatives). JuMP's handling of nonlinear expressions is less efficient (especially in terms of memory usage). A straightforward implementation of the model in JuMP using many nonlinear expressions results in memory usage that grows very quickly with the number of products per market. This can become prohibitive when the number of produces per market exceeds 50 or so. ","category":"page"},{"location":"implementation/","page":"Developer Notes","title":"Developer Notes","text":"To use JuMP with many products, it is useful to limit the presence of nonlinear expressions to involve as few constraints and variables as possible. This can be done by introducing auxillary varibles subject to linear and/or quadratic constraints. A good rule of thumb is that introducing auxillary variables will be beneficial when it makes the Hessian more sparse.","category":"page"},{"location":"implementation/","page":"Developer Notes","title":"Developer Notes","text":"For example, rather than simply defining the share constraints as","category":"page"},{"location":"implementation/","page":"Developer Notes","title":"Developer Notes","text":"sjt = frac1S sum_i=1^S fracexp(deltajt + xjt(nuit * sigma)1 + sum_ell exp(deltaellt + xellt*nuit)","category":"page"},{"location":"implementation/","page":"Developer Notes","title":"Developer Notes","text":"the code defines intermediate variables, u, n, and d with extra constraints","category":"page"},{"location":"implementation/","page":"Developer Notes","title":"Developer Notes","text":"uijt = deltajt + xjt(nuit * sigma)","category":"page"},{"location":"implementation/","page":"Developer Notes","title":"Developer Notes","text":"nijt = exp(uijt)","category":"page"},{"location":"implementation/","page":"Developer Notes","title":"Developer Notes","text":"dit = 1 + sum_j nijt","category":"page"},{"location":"implementation/","page":"Developer Notes","title":"Developer Notes","text":"siijt*dit = nijt","category":"page"},{"location":"implementation/","page":"Developer Notes","title":"Developer Notes","text":"sjt = frac1S sum_i=1^S siijt","category":"page"},{"location":"implementation/","page":"Developer Notes","title":"Developer Notes","text":"The feasible set is unchanged, but now only the constraint involving n and u is not linear or quadratic. ","category":"page"},{"location":"implementation/","page":"Developer Notes","title":"Developer Notes","text":"Note that estimateRCIVlogit has not yet been modified in this way. Hence, estimateRCIVlogit with method =:MPEC or :GEL is not very efficient for models with a large number of products per market.","category":"page"}]
}
