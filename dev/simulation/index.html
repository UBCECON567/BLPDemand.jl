<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Simulations · BLPDemand.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">BLPDemand.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Simulations</a><ul class="internal"><li><a class="tocitem" href="#Generate-Data"><span>Generate Data</span></a></li><li><a class="tocitem" href="#Instruments"><span>Instruments</span></a></li><li><a class="tocitem" href="#Estimation"><span>Estimation</span></a></li><li><a class="tocitem" href="#Inference"><span>Inference</span></a></li><li><a class="tocitem" href="#Optimal-Instruments"><span>Optimal Instruments</span></a></li><li><a class="tocitem" href="#Calculating-Elasticities"><span>Calculating Elasticities</span></a></li></ul></li><li><a class="tocitem" href="../functions/">Function Reference</a></li><li><a class="tocitem" href="../implementation/">Developer Notes</a></li><li><a class="tocitem" href="../replicateblp/">Replicating BLP</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Simulations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Simulations</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/UBCECON567/BLPDemand.jl/blob/master/docs/src/simulation.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Simulations"><a class="docs-heading-anchor" href="#Simulations">Simulations</a><a id="Simulations-1"></a><a class="docs-heading-anchor-permalink" href="#Simulations" title="Permalink"></a></h1><p>Here we perform some monte-carlo simulations to illustrute package usage and estimator performance. See <a href="@ref"><code>Model</code></a> for an overview of the model. The tests directory contains some additional examples.</p><h2 id="Generate-Data"><a class="docs-heading-anchor" href="#Generate-Data">Generate Data</a><a id="Generate-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Generate-Data" title="Permalink"></a></h2><pre><code class="language-julia hljs">using BLPDemand, Statistics, PrettyTables, Printf, Random, LinearAlgebra
K = 2             # number of characteristics
J = 6             # number of products
S = 10            # draws of nu
T = 100           # number of markets
β = ones(K)*2
β[1] = -1.5       # important for equilibrium that higher prices lower sales
σ = ones(K)
σ[1] = 0.2
γ = ones(1)*0.1
Random.seed!(98426)

(sim, ξ, ω) = simulateBLP(J,T, β, σ, γ, S, varξ=0.2, varω=0.2);
@show quantile(vcat((d-&gt;d.s[:]).(sim)...), [0, 0.05, 0.5, 0.95, 1])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-element Vector{Float64}:
 0.00014225499708970805
 0.008799502157570303
 0.07110141519276794
 0.23451158881708067
 0.43509329194476337</code></pre><p>Estimation will encounter numerical difficulties if market shares are very close (within 1e-4) to 0 or 1. The above range should be fine. </p><h2 id="Instruments"><a class="docs-heading-anchor" href="#Instruments">Instruments</a><a id="Instruments-1"></a><a class="docs-heading-anchor-permalink" href="#Instruments" title="Permalink"></a></h2><p>In the simulated data <code>sim[].x[2:end,:]</code> and <code>sim[].w</code> are uncorrelated with <code>ξ</code> and <code>ω</code>, but price, <code>sim[].x[1,:]</code>, is endogenous. The price of the <code>j</code>th firm will depend on the characteristics and costs of all other goods, so these are available as instruments. <a href="../functions/#BLPDemand.makeivblp-Tuple{AbstractMatrix}"><code>makeivblp</code></a> is a convenience function that constructs the sum of all other firms&#39; exogenous variables to use as instruments. This is similar to what Berry, Levinsohn, and Pakes (1995) do. We will see below though that much more accurate estimates can be obtained by using the optimal instruments. <code>makeivblp</code> is used by <code>simulateBLP</code> to generate <code>sim[].zd</code> and <code>sim[].zs</code>.</p><h2 id="Estimation"><a class="docs-heading-anchor" href="#Estimation">Estimation</a><a id="Estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Estimation" title="Permalink"></a></h2><p>We can now estimate the model. Three methods are available: GMM with nested-fixed point (<code>:NFXP</code>), constrained GMM (<code>:MPEC</code>), and constrained GEL (<code>:GEL</code>). See <a href="../functions/#BLPDemand.estimateBLP-Tuple{Vector{MarketData}}"><code>estimateBLP</code></a>. </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @time nfxp = estimateBLP(sim, method=:NFXP, verbose=false)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: LinearAlgebra.SingularException(1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @time mpec = estimateBLP(sim, method=:MPEC,verbose=true);</code><code class="nohighlight hljs ansi" style="display:block;">
******************************************************************************
This program contains Ipopt, a library for large-scale nonlinear optimization.
 Ipopt is released as open source code under the Eclipse Public License (EPL).
         For more information visit https://github.com/coin-or/Ipopt
******************************************************************************

This is Ipopt version 3.14.4, running with linear solver MUMPS 5.4.1.

Number of nonzeros in equality constraint Jacobian...:   183006
Number of nonzeros in inequality constraint Jacobian.:        0
Number of nonzeros in Lagrangian Hessian.............:    76806

Total number of variables............................:    21011
                     variables with only lower bounds:     6002
                variables with lower and upper bounds:        0
                     variables with only upper bounds:        0
Total number of equality constraints.................:    21006
Total number of inequality constraints...............:        0
        inequality constraints with only lower bounds:        0
   inequality constraints with lower and upper bounds:        0
        inequality constraints with only upper bounds:        0

iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
   0  0.0000000e+00 4.05e+00 1.85e-03  -1.0 0.00e+00    -  0.00e+00 0.00e+00   0
   1  1.9733489e+00 2.49e+02 7.22e+02  -1.0 1.04e+01    -  6.73e-02 8.12e-01h  1
   2  2.1204110e+00 9.23e+01 3.79e+01  -1.0 1.32e+00    -  3.46e-01 9.90e-01h  1
   3  2.3098520e+00 3.37e+01 2.04e+00  -1.0 9.91e-01    -  1.00e+00 1.00e+00h  1
   4  2.3706054e+00 2.21e+01 1.10e+03  -1.0 1.92e+00    -  7.40e-01 4.34e-01h  1
   5  2.3752570e+00 1.13e+01 4.01e+02  -1.0 1.02e+00    -  1.00e+00 6.59e-01h  1
   6  2.4814975e+00 5.72e+00 2.35e+02  -1.0 1.01e+00    -  1.00e+00 6.96e-01h  1
   7  2.6677743e+00 2.43e+00 1.46e+02  -1.0 1.01e+00    -  1.00e+00 8.44e-01h  1
   8  3.2165456e+00 9.23e-01 5.66e+02  -1.0 1.12e+00    -  4.09e-01 6.86e-01H  1
   9  2.6972235e+00 6.05e-01 2.84e+02  -1.0 2.03e+00    -  1.51e-01 3.46e-01F  1
iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
  10  1.8468491e+00 1.06e+00 1.89e+02  -1.0 2.74e+00    -  4.00e-01 8.29e-01F  1
  11  1.9544199e+00 2.91e-02 3.65e+02  -1.0 1.76e+00    -  2.37e-01 1.00e+00f  1
  12  2.0435843e+00 2.30e+00 4.59e+01  -1.0 2.40e+01  -2.0 1.00e+00 1.00e+00F  1
  13  2.4961629e+00 2.65e+00 2.55e+00  -1.0 6.90e+00    -  1.00e+00 1.00e+00h  1
  14  3.5451515e+00 1.83e+00 1.11e+01  -1.0 1.91e+01    -  1.00e+00 1.00e+00H  1
  15  4.6983309e+00 2.55e-01 5.66e+00  -1.0 1.52e+01    -  1.00e+00 1.00e+00H  1
  16  4.5150428e+00 8.34e-02 1.89e-01  -1.0 3.17e+00    -  1.00e+00 1.00e+00h  1
  17  2.0499528e+00 2.41e+01 6.60e+02  -2.5 7.53e+01    -  4.01e-01 8.70e-01f  1
  18  1.9224816e+00 2.00e+00 5.86e+02  -2.5 1.84e+01    -  1.10e-02 1.00e+00h  1
  19  1.8429577e+00 9.85e-02 7.16e+01  -2.5 1.32e+00    -  8.76e-01 1.00e+00h  1
iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
  20  1.6249801e+00 2.07e-01 3.71e-01  -2.5 2.66e+00    -  1.00e+00 1.00e+00h  1
  21  1.2018818e+00 8.89e-01 1.07e+01  -2.5 5.24e+00    -  5.73e-01 1.00e+00h  1
  22  1.2438820e+00 1.14e-01 2.48e-01  -2.5 6.81e-01    -  1.00e+00 1.00e+00h  1
  23  1.2475816e+00 7.05e-04 3.15e-03  -2.5 2.39e-02    -  1.00e+00 1.00e+00h  1
  24  1.1691255e+00 2.07e-01 1.04e+01  -3.8 1.97e+00    -  7.90e-01 1.00e+00h  1
  25  1.1961278e+00 5.08e-03 4.46e-02  -3.8 1.02e-01    -  1.00e+00 1.00e+00h  1
  26  1.1966428e+00 3.44e-04 7.97e-04  -3.8 6.29e-02    -  1.00e+00 1.00e+00h  1
  27  1.1963162e+00 1.03e-03 1.11e-01  -5.7 1.16e-01    -  9.89e-01 1.00e+00h  1
  28  1.1964911e+00 1.99e-08 6.09e-07  -5.7 5.18e-04    -  1.00e+00 1.00e+00h  1
  29  1.1964911e+00 1.58e-07 1.26e-06  -8.6 1.43e-03    -  1.00e+00 1.00e+00h  1
iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
  30  1.1964911e+00 2.66e-15 1.14e-13  -8.6 8.87e-08    -  1.00e+00 1.00e+00h  1

Number of Iterations....: 30

                                   (scaled)                 (unscaled)
Objective...............:   1.1964910992637900e+00    1.1964910992637900e+00
Dual infeasibility......:   1.1368683772161603e-13    1.1368683772161603e-13
Constraint violation....:   2.6645352591003757e-15    2.6645352591003757e-15
Variable bound violation:   0.0000000000000000e+00    0.0000000000000000e+00
Complementarity.........:   2.5059035857255081e-09    2.5059035857255081e-09
Overall NLP error.......:   2.5059035857255081e-09    2.5059035857255081e-09


Number of objective function evaluations             = 39
Number of objective gradient evaluations             = 31
Number of equality constraint evaluations            = 39
Number of inequality constraint evaluations          = 0
Number of equality constraint Jacobian evaluations   = 31
Number of inequality constraint Jacobian evaluations = 0
Number of Lagrangian Hessian evaluations             = 30
Total seconds in IPOPT                               = 7.116

EXIT: Optimal Solution Found.
 21.552512 seconds (18.24 M allocations: 1.007 GiB, 1.41% gc time, 80.94% compilation time)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @time gel = estimateBLP(sim, method=:GEL,verbose=true);</code><code class="nohighlight hljs ansi" style="display:block;">This is Ipopt version 3.14.4, running with linear solver MUMPS 5.4.1.

Number of nonzeros in equality constraint Jacobian...:   190200
Number of nonzeros in inequality constraint Jacobian.:      600
Number of nonzeros in Lagrangian Hessian.............:    84600

Total number of variables............................:    21605
                     variables with only lower bounds:     6602
                variables with lower and upper bounds:        0
                     variables with only upper bounds:        0
Total number of equality constraints.................:    21006
Total number of inequality constraints...............:        1
        inequality constraints with only lower bounds:        0
   inequality constraints with lower and upper bounds:        0
        inequality constraints with only upper bounds:        1

iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
   0 -2.7631021e+03 5.00e+00 9.98e+01  -1.0 0.00e+00    -  0.00e+00 0.00e+00   0
   1 -2.7652637e+03 4.98e+00 8.40e+01  -1.0 1.01e+01    -  9.74e-02 6.28e-03h  1
   2 -3.6406993e+03 3.09e+02 9.84e+03  -1.0 9.33e+00  -2.0 5.83e-01 9.18e-01h  1
   3 -3.6756298e+03 2.49e+02 8.86e+03  -1.0 1.08e+00    -  9.54e-01 2.14e-01h  1
   4 -3.8402591e+03 9.25e+01 3.61e+03  -1.0 1.07e+00    -  9.60e-01 9.91e-01h  1
   5 -3.8415736e+03 3.40e+01 2.10e+03  -1.0 1.00e+00    -  1.00e+00 1.00e+00h  1
   6 -3.8412762e+03 1.25e+01 7.19e+02  -1.0 9.94e-01    -  8.35e-01 1.00e+00h  1
   7 -3.8412089e+03 4.62e+00 2.85e+02  -1.0 9.94e-01    -  1.00e+00 1.00e+00h  1
   8 -3.8415006e+03 1.68e+00 3.04e+01  -1.0 9.93e-01    -  1.00e+00 1.00e+00h  1
   9 -3.8417956e+03 8.20e-01 3.79e+01  -1.0 9.35e-01    -  4.30e-01 6.41e-01h  1
iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
  10 -3.8417317e+03 7.60e-01 9.17e+01  -1.0 2.70e+00    -  2.24e-01 7.32e-02f  2
  11 -3.8416237e+03 6.43e-01 3.18e+02  -1.0 1.98e+00    -  1.00e+00 1.55e-01h  2
  12 -3.8414726e+03 5.22e-01 3.53e+02  -1.0 2.11e+00    -  5.76e-01 1.89e-01h  3
  13 -3.8413408e+03 4.21e-01 2.64e+02  -1.0 2.61e+00    -  1.00e+00 1.95e-01h  3
  14 -3.8411973e+03 3.47e-01 2.45e+02  -1.0 3.39e+00    -  8.78e-01 1.77e-01h  3
  15 -3.8409164e+03 3.94e-01 1.67e+02  -1.0 4.24e+00    -  1.00e+00 3.34e-01f  2
  16 -3.8406315e+03 6.00e-01 2.37e+02  -1.0 7.10e+00    -  1.00e+00 2.55e-01f  2
  17 -3.8401696e+03 1.52e+00 1.31e+02  -1.0 9.64e+00    -  5.46e-01 4.57e-01F  1
  18 -3.8401625e+03 1.42e+00 6.41e+01  -1.0 1.38e+01    -  2.11e-01 1.38e-01h  1
  19 -3.8400224e+03 5.44e+00 4.11e+01  -1.0 1.29e+01    -  1.00e+00 1.00e+00f  1
iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
  20 -3.8407206e+03 1.07e+01 8.48e+01  -1.0 2.87e+01    -  7.34e-01 1.00e+00f  1
  21 -3.8418449e+03 1.13e+01 2.23e+01  -1.0 4.61e+01    -  1.00e+00 1.00e+00h  1
  22 -3.8424423e+03 2.93e+00 2.59e+00  -1.0 3.62e+01    -  1.00e+00 1.00e+00h  1
  23 -3.8427106e+03 5.96e-01 5.76e-01  -1.0 1.57e+01    -  1.00e+00 1.00e+00h  1
  24 -3.8414221e+03 4.39e+01 8.25e+02  -1.7 1.65e+02    -  3.51e-01 1.00e+00F  1
  25 -3.8412551e+03 4.45e-01 1.61e+00  -1.7 5.35e+01    -  1.00e+00 1.00e+00h  1
  26 -3.8400232e+03 3.38e+00 5.33e+01  -1.7 7.54e+01    -  5.31e-01 1.00e+00H  1
  27 -3.8399425e+03 1.49e-01 2.03e+00  -1.7 7.02e+00    -  1.00e+00 1.00e+00h  1
  28 -3.8398929e+03 7.65e-02 2.23e-01  -1.7 2.34e+00    -  1.00e+00 1.00e+00h  1
  29 -3.8398923e+03 2.39e-05 1.75e-04  -1.7 3.42e-02    -  1.00e+00 1.00e+00h  1
iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
  30 -3.8394522e+03 4.78e+00 9.56e+01  -3.8 2.06e+01    -  4.74e-01 1.00e+00f  1
  31 -3.8394226e+03 3.11e-02 3.91e+01  -3.8 3.61e+00    -  7.74e-01 1.00e+00h  1
  32 -3.8392752e+03 2.18e-01 5.29e+00  -3.8 3.02e+00    -  8.36e-01 1.00e+00h  1
  33 -3.8391305e+03 7.90e-01 4.52e+00  -3.8 5.32e+00    -  1.00e+00 1.00e+00h  1
  34 -3.8391507e+03 2.35e-01 3.95e-01  -3.8 1.74e+00    -  1.00e+00 1.00e+00h  1
  35 -3.8391598e+03 3.18e-04 2.73e-03  -3.8 1.59e-01    -  1.00e+00 1.00e+00h  1
  36 -3.8391597e+03 1.61e-09 8.15e-08  -3.8 2.14e-04    -  1.00e+00 1.00e+00h  1
  37 -3.8391588e+03 5.97e-03 6.70e-01  -5.7 3.54e-01    -  9.68e-01 1.00e+00f  1
  38 -3.8391592e+03 7.89e-07 5.12e-06  -5.7 1.98e-03    -  1.00e+00 1.00e+00h  1
  39 -3.8391592e+03 9.37e-07 4.69e-06  -8.6 4.34e-03    -  1.00e+00 1.00e+00h  1
iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
  40 -3.8391592e+03 1.42e-14 3.03e-13  -8.6 3.79e-07    -  1.00e+00 1.00e+00h  1

Number of Iterations....: 40

                                   (scaled)                 (unscaled)
Objective...............:   3.8391591589965437e+03   -3.8391591589965437e+03
Dual infeasibility......:   3.0323045748237569e-13    3.0323045748237569e-13
Constraint violation....:   1.4210854715202004e-14    1.4210854715202004e-14
Variable bound violation:   0.0000000000000000e+00    0.0000000000000000e+00
Complementarity.........:   2.5059037806488364e-09    2.5059037806488364e-09
Overall NLP error.......:   2.5059037806488364e-09    2.5059037806488364e-09


Number of objective function evaluations             = 78
Number of objective gradient evaluations             = 41
Number of equality constraint evaluations            = 78
Number of inequality constraint evaluations          = 78
Number of equality constraint Jacobian evaluations   = 41
Number of inequality constraint Jacobian evaluations = 41
Number of Lagrangian Hessian evaluations             = 40
Total seconds in IPOPT                               = 5.248

EXIT: Optimal Solution Found.
  6.425778 seconds (3.04 M allocations: 216.230 MiB, 0.89% gc time, 14.37% compilation time)</code></pre><pre><code class="language- hljs">tbl = vcat([&quot;&quot; &quot;True&quot; &quot;NFXP&quot; &quot;MPEC&quot; &quot;GEL&quot;],
           [(i-&gt;&quot;β[$i]&quot;).(1:length(β)) β nfxp.β mpec.β gel.β],
           [(i-&gt;&quot;σ[$i]&quot;).(1:length(σ)) σ nfxp.σ mpec.σ gel.σ],
           [(i-&gt;&quot;γ[$i]&quot;).(1:length(γ)) γ nfxp.γ mpec.γ gel.γ])
pretty_table(tbl, noheader=true, formatter=ft_printf(&quot;%6.3f&quot;,3:5))</code></pre><p>In the absence of optimization error and other numeric problems, <code>:NFXP</code> and <code>:MPEC</code> should produce identical results.  In finite sample, we should expect the GEL estimates to differ. All three methods are consistent, but GEL is also asymptotically efficient (for a fixed choice of <code>z</code>; different <code>z</code> can have large effects on efficiency).</p><h2 id="Inference"><a class="docs-heading-anchor" href="#Inference">Inference</a><a id="Inference-1"></a><a class="docs-heading-anchor-permalink" href="#Inference" title="Permalink"></a></h2><p><a href="../functions/#BLPDemand.varianceBLP-Tuple{Any, Any, Any, Vector{MarketData}}"><code>varianceBLP</code></a> computes the variance of the estimates produced by either of GMM estimation methods.<sup class="footnote-reference"><a id="citeref-simdraws" href="#footnote-simdraws">[simdraws]</a></sup></p><p>[^simdraws:] The variance calculation ignores uncertainty from Monte-Carlo integration. For this to be valid, we must have the number of simulation draws grow faster than the sample size. In our notation, <code>S</code> is the number of simulation draws per observation, so it is sufficient at that <span>$S \to \infty$</span> as <span>$T \to \infty$</span>.</p><pre><code class="language- hljs">vnfxp = varianceBLP(nfxp.β, nfxp.σ, nfxp.γ, sim);
vmpec = varianceBLP(mpec.β, mpec.σ, mpec.γ, sim);
nothing</code></pre><p>Inference for GEL has not been directly implemented. However, GEL is first order asymptotically equivalent to efficiently weigthed GMM. In other words, GEL estimates have the same asymptotic variance as efficiently weighted GMM. </p><pre><code class="language- hljs">v = varianceBLP(gel.β, gel.σ, gel.γ, sim)
vgel = varianceBLP(gel.β, gel.σ, gel.γ, sim, W=inv(v.varm))

f(v) = @sprintf(&quot;(%.2f)&quot;, norm(sqrt(Complex(v))))
vtbl = permutedims(hcat(tbl[1,:],
                        [hcat(tbl[i+1,:],
                              [&quot;&quot;, &quot;&quot;, f.([vnfxp.Σ[i,i], vmpec.Σ[i,i], vgel.Σ[i,i]])...])
                         for i in 1:size(vgel.Σ,1)]...
                        ))
pretty_table(vtbl, noheader=true, formatter=ft_printf(&quot;%6.3f&quot;,3:5))</code></pre><p>These reusults look pretty good. In additional experiments (not shown)  the results were somewhat sensitive to the simulation design and choice of instruments (see <a href="../functions/#BLPDemand.makeivblp-Tuple{AbstractMatrix}"><code>makeivblp</code></a>).</p><h2 id="Optimal-Instruments"><a class="docs-heading-anchor" href="#Optimal-Instruments">Optimal Instruments</a><a id="Optimal-Instruments-1"></a><a class="docs-heading-anchor-permalink" href="#Optimal-Instruments" title="Permalink"></a></h2><p>The above estimators use the unconditional moment restriction </p><p class="math-container">\[E[(\xi, \omega) z] =0.\]</p><p>If we assume the conditional moment restriction,</p><p class="math-container">\[E[(\xi, \omega) | z] =0.\]</p><p>then, we can potentially use any function of <span>$z$</span> to form unconditional moments. </p><p class="math-container">\[E[(\xi, \omega) f(z)] =0.\]</p><p>The optimal (minimal asymptotic variance) choice of <code>f(z)</code> is </p><p class="math-container">\[\frac{\partial}{\partial \theta} E[(\xi, \omega) | z] =0.\]</p><p><a href="../functions/#BLPDemand.optimalIV-Tuple{Any, Any, Any, Vector{MarketData}}"><code>optimalIV</code></a> approximates the optimal instruments by taking as initial estimate of <span>$\theta$</span>, computing <span>$\frac{\partial (\xi, \omega)}{\partial \theta}$</span> for each observation in the data, and then regressing this on a polynomial function of <span>$z$</span>. Using the fitted values from this regression as <span>$f(z)$</span> results in much more precise estimates of <span>$\theta$</span>.<sup class="footnote-reference"><a id="citeref-z" href="#footnote-z">[z]</a></sup></p><pre><code class="language-julia hljs">sim=optimalIV(mpec.β, max.(mpec.σ, 0.1), # calculating optimal IV with σ near 0 gives poor peformance
              mpec.γ, sim, degree=3);
nothing</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @time nfxp = estimateBLP(sim, method=:NFXP, verbose=false)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: LinearAlgebra.SingularException(1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @time mpec = estimateBLP(sim, method=:MPEC,verbose=false);</code><code class="nohighlight hljs ansi" style="display:block;">  3.658335 seconds (2.32 M allocations: 176.015 MiB, 1.16% gc time)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @time gel = estimateBLP(sim, method=:GEL,verbose=false);</code><code class="nohighlight hljs ansi" style="display:block;">  5.715276 seconds (2.48 M allocations: 185.551 MiB, 2.04% gc time)</code></pre><pre><code class="language- hljs">vnfxp = varianceBLP(nfxp.β, nfxp.σ, nfxp.γ, sim)
vmpec = varianceBLP(mpec.β, mpec.σ, mpec.γ, sim)
v = varianceBLP(gel.β, gel.σ, gel.γ, sim)
vgel = varianceBLP(gel.β, gel.σ, gel.γ, sim, W=inv(v.varm))

f(v) = @sprintf(&quot;(%.2f)&quot;, norm(sqrt(Complex(v))))
tbl = vcat([&quot;&quot; &quot;True&quot; &quot;NFXP&quot; &quot;MPEC&quot; &quot;GEL&quot;],
           [(i-&gt;&quot;β[$i]&quot;).(1:length(β)) β nfxp.β mpec.β gel.β],
           [(i-&gt;&quot;σ[$i]&quot;).(1:length(σ)) σ nfxp.σ mpec.σ gel.σ],
           [(i-&gt;&quot;γ[$i]&quot;).(1:length(γ)) γ nfxp.γ mpec.γ gel.γ])
vtbl = permutedims(hcat(tbl[1,:],
                        [hcat(tbl[i+1,:],
                              [&quot;&quot;, &quot;&quot;, f.([vnfxp.Σ[i,i], vmpec.Σ[i,i], vgel.Σ[i,i]])...])
                         for i in 1:size(vgel.Σ,1)]...
                        ))
pretty_table(vtbl, noheader=true, formatter=ft_printf(&quot;%6.3f&quot;,3:5))</code></pre><p>We see that with the optimal instruments all three methods produce essentially the same results (in this case, theoretically, NFXP=MPEC, and both are asymptotically equivalent to GEL, so this is expected). Moreover, the estimates are now much more precise and quite close to the true parameter values.</p><h2 id="Calculating-Elasticities"><a class="docs-heading-anchor" href="#Calculating-Elasticities">Calculating Elasticities</a><a id="Calculating-Elasticities-1"></a><a class="docs-heading-anchor-permalink" href="#Calculating-Elasticities" title="Permalink"></a></h2><p>Using <a href="../functions/#BLPDemand.share-Tuple{AbstractVector, AbstractVector, AbstractMatrix, AbstractMatrix}"><code>share</code></a> and the <code>ForwardDiff.jl</code> package, we can calculate elasticities of demand with respect to each characteristic.</p><pre><code class="language-julia hljs">using ForwardDiff

function elasticity(β, σ, γ, dat, ξ)
  T = length(dat)
  K,J = size(dat[1].x)
  etype = typeof(dat[1].x[:,1]&#39;*β+ξ[1][1])
  e = Array{Array{etype,3},1}(undef, T)
  for t in 1:T
    @views xt = dat[t].x
    st(x) = share(x&#39;*β + ξ[t], σ, x, dat[t].ν)
    ∂s = reshape(ForwardDiff.jacobian(st, xt), J, K, J)
    s = st(xt)
    e[t] = zeros(etype, J,K,J)
    for k in 1:K
      for j in 1:J
        e[t][:,k,j] .= ∂s[:,k,j]./s .* xt[k,j]
      end
    end
  end
  return e
end

function avg_price_elasticity(β,σ,γ, dat)
  ξ = Vector{Vector{eltype(β)}}(undef, T)
  for t in 1:T
    ξ[t] = delta(dat[t].s, dat[t].x, dat[t].ν, σ) - dat[t].x&#39;*β
  end
  e=elasticity(β,σ,γ,dat,ξ)
  avge = zeros(eltype(e[1]),size(e[1]))
  # this assumes J is the same for all markets
  for t in 1:T
    avge .+= e[t]
  end
  avge /= T
  avge[:,1,:]
end

price_elasticity = avg_price_elasticity(mpec.β, mpec.σ, mpec.γ, sim)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">6×6 Matrix{Float64}:
 -2.9041     0.222845   0.261016   0.271805   0.228282   0.26534
  0.218521  -2.8284     0.254256   0.285864   0.231661   0.253308
  0.22962    0.223258  -2.76996    0.274542   0.237438   0.261844
  0.217709   0.227497   0.262058  -2.53823    0.230841   0.256407
  0.219575   0.226313   0.267792   0.286091  -2.74592    0.250561
  0.226352   0.227712   0.267249   0.271318   0.228572  -2.66944</code></pre><p>Standard errors of elasticities and other quantities calculated from estimates can be calculated using the delta method.</p><pre><code class="language- hljs">D = ForwardDiff.jacobian(θ-&gt;avg_price_elasticity(θ[1:K], θ[(K+1):(2K)], θ[(2K+1):end], sim), [mpec.β;mpec.σ;mpec.γ])
V = D*vmpec.Σ*D&#39;
se = reshape(sqrt.(diag(V)), size(price_elasticity))

tbl = Array{Any, 2}(undef, 2J+1, J+1)
tbl[1,1]=&quot;&quot;
for j in 1:J
  tbl[1,j+1] = &quot;price $j&quot;
  tbl[2j,1] = &quot;share $j&quot;
  tbl[2j+1,1] = &quot;&quot;
  for l in 1:J
    tbl[2j, l+1] = price_elasticity[j,l]
    tbl[2j+1, l+1] = @sprintf(&quot;(%.3f)&quot;,se[j,l])
  end
end
pretty_table(tbl, noheader=true, formatter=ft_printf(&quot;%6.3f&quot;, 2:(J+1)))       </code></pre><p>The table above shows the estimated average elasticity of each good&#39;s share with respect to each good&#39;s price. Standard errors are in parentheses.</p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-z"><a class="tag is-link" href="#citeref-z">z</a>The choice of <code>z</code> still matters when using <code>optimalIV.</code> For firm <code>j</code>, the values of <code>x[2:end,l,t]</code> (for both <code>l=j</code> and <code>l != j</code>) are all potential instruments for <code>x[1,j,t]</code>. However, <code>makeivblp</code> does not use all of these. It instead uses their sum and the sum of <code>exp(-(x[2:end,j,t] - x[2:end,l,t])^2)</code>. Adjusting these choices might give better results.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../functions/">Function Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 27 January 2023 18:30">Friday 27 January 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
