---
title       : "Using MTK.jl for BLP estimation"
subtitle    :
author      : Paul Schrimpf
date        : `j using Dates; print(Dates.today())`
bibliography: "blp.bib"
link-citations: true
options:
      out_width : 100%
      wrap : true
      fig_width : 800
      dpi : 192
---

[![](https://i.creativecommons.org/l/by-sa/4.0/88x31.png)](http://creativecommons.org/licenses/by-sa/4.0/)

This work is licensed under a [Creative Commons Attribution-ShareAlike
4.0 International
License](http://creativecommons.org/licenses/by-sa/4.0/)

# Simulate Data

```julia
using BLPDemand, Statistics, PrettyTables, Printf, Random, LinearAlgebra
K = 2             # number of characteristics
J = 2             # number of products
S = 4            # draws of nu
T = 50           # number of markets
β = ones(K)*2
β[1] = -1.5       # important for equilibrium that higher prices lower sales
σ = ones(K)
σ[1] = 0.2
γ = ones(1)*0.1
Random.seed!(98426)

(sim, ξ, ω) = simulateBLP(J,T, β, σ, γ, S, varξ=0.2, varω=0.2);
@show quantile(vcat((d->d.s[:]).(sim)...), [0, 0.05, 0.5, 0.95, 1])
```

# MTK

```julia
using ModelingToolkit, GalacticOptim, Symbolics, Optim, MathOptInterface, Ipopt
#import DiffEqBase
#import RuntimeGeneratedFunctions: @RuntimeGeneratedFunction
#import ModelingToolkit: varmap_to_vars

include("eqcop.jl")

sharefunc(δ, Σ, x, ν) =
  reshape(sum(( exp.(δ .+ x'*Σ*ν)) ./ (1 .+ sum(exp.(δ .+ x'*Σ*ν), dims=1)), dims=2)/size(ν,2), length(δ))

function blpmtk(data::AbstractVector{MarketData})
  K, _ = size(data[1].x)
  L, _ = size(data[1].w)
  @variables β[1:K], γ[1:L], σ[1:K]
  δ = Vector{typeof(β)}(undef, length(data))
  Σ = Matrix(Diagonal(σ))
  share = similar(δ)
  #@variables ν[1:K]
  #ϕ(ν) = exp(-(ν'*ν))/((2π)^(K/2))
  #∫ = Integral(ν ∈ # ProductDomain([DomainSets.OpenInterval(-Inf, Inf) for k in 1:K]))
  #∫ = Integral(ν ∈ DomainSets.OpenInterval(-Inf,Inf))
  JT = sum(length(d.s) for d in data)
  shareeq = Vector{Symbolics.Arr{Any,2}}(undef, length(data))
  #sharefn = Vector{Symbolics.Arr{Num,2}}(undef, length(data))
  for i in eachindex(data)
    #x = data[i].x
    #ν = data[i].ν
    xs = Symbol("x$i")
    νs = Symbol("ν$i")
    J = length(data[i].s)
    v = Symbol("δ$i")
    δ[i] = (@variables $v[1:J])[1]
    v = Symbol("s$i")
    share[i] = (@variables $v[1:J])[1]
  end
  cons = reshape(vcat((data[i].s .~ sharefunc(collect(δ[i]), collect(Σ), data[i].x, data[i].ν) for i in eachindex(data))...), JT)
  moments = sum(data[i].zd*(collect(δ[i]) - data[i].x'*collect(β)) for i in eachindex(data))/length(data)
  W = I

  loss = length(data)*moments'*W*moments;

  params = vcat(collect(β), collect(σ), collect.(δ)...) # states to an ODE, but params for econometrics
  sys = OptimizationSystem(loss, params, [], name=:BLP1, equality_constraints=cons)

  initial_vals = vcat( [-1, 1], ones(K), zeros(J*T))
  u0 = [p => v for (p, v) in zip(params, initial_vals)]

  # make sure exp(δ + xΣν) is finite
  maxxν = maximum(maximum(vec(d.x*d.ν)) for d in sim)
  maxσ = 10.
  maxδ = minimum(300. - maxxν*maxσ)
  lb = [-10, -10,    # β
        fill(0.05,K)...,  # σ
        fill(-maxδ, JT)...] # δ
  ub = [0.01, 10,
        fill(maxσ, K)...,
        fill(maxδ, JT)...] # δ
  prob = EQCOP.equalityConstrainedOptimizationProblem(sys, u0, [],lb=lb,ub=ub,grad=true,hess=true, sparse=false)


  return(prob)
end

prob = blpmtk(sim)

sol = solve(prob,  Ipopt.Optimizer(); max_iter = 250,
            print_level=5)



soln = solve(prob, IPNewton(), show_trace=true)
#sharefunc(collect(δ[i]), Σ, data[i].x, data[i].ν)[1] isa Num

```

